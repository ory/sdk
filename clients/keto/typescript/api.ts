/* tslint:disable */
/* eslint-disable */
/**
 * Ory Keto API
 * Documentation for all of Ory Keto\'s REST APIs. gRPC is documented separately. 
 *
 * The version of the OpenAPI document: v25.4.0
 * Contact: hi@ory.sh
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Batch Check Permission Body
 * @export
 * @interface BatchCheckPermissionBody
 */
export interface BatchCheckPermissionBody {
    /**
     * 
     * @type {Array<Relationship>}
     * @memberof BatchCheckPermissionBody
     */
    'tuples'?: Array<Relationship>;
}
/**
 * Batch Check Permission Result
 * @export
 * @interface BatchCheckPermissionResult
 */
export interface BatchCheckPermissionResult {
    /**
     * An array of check results. The order aligns with the input order.
     * @type {Array<CheckPermissionResultWithError>}
     * @memberof BatchCheckPermissionResult
     */
    'results': Array<CheckPermissionResultWithError>;
}
/**
 * 
 * @export
 * @interface CheckOplSyntaxResult
 */
export interface CheckOplSyntaxResult {
    /**
     * The list of syntax errors
     * @type {Array<ParseError>}
     * @memberof CheckOplSyntaxResult
     */
    'errors'?: Array<ParseError>;
}
/**
 * The content of the allowed field is mirrored in the HTTP status code.
 * @export
 * @interface CheckPermissionResult
 */
export interface CheckPermissionResult {
    /**
     * whether the relation tuple is allowed
     * @type {boolean}
     * @memberof CheckPermissionResult
     */
    'allowed': boolean;
}
/**
 * Check Permission Result With Error
 * @export
 * @interface CheckPermissionResultWithError
 */
export interface CheckPermissionResultWithError {
    /**
     * whether the relation tuple is allowed
     * @type {boolean}
     * @memberof CheckPermissionResultWithError
     */
    'allowed': boolean;
    /**
     * any error generated while checking the relation tuple
     * @type {string}
     * @memberof CheckPermissionResultWithError
     */
    'error'?: string;
}
/**
 * Create Relationship Request Body
 * @export
 * @interface CreateRelationshipBody
 */
export interface CreateRelationshipBody {
    /**
     * Namespace to query
     * @type {string}
     * @memberof CreateRelationshipBody
     */
    'namespace'?: string;
    /**
     * Object to query
     * @type {string}
     * @memberof CreateRelationshipBody
     */
    'object'?: string;
    /**
     * Relation to query
     * @type {string}
     * @memberof CreateRelationshipBody
     */
    'relation'?: string;
    /**
     * SubjectID to query  Either SubjectSet or SubjectID can be provided.
     * @type {string}
     * @memberof CreateRelationshipBody
     */
    'subject_id'?: string;
    /**
     * 
     * @type {SubjectSet}
     * @memberof CreateRelationshipBody
     */
    'subject_set'?: SubjectSet;
}
/**
 * The standard Ory JSON API error format.
 * @export
 * @interface ErrorGeneric
 */
export interface ErrorGeneric {
    /**
     * 
     * @type {GenericError}
     * @memberof ErrorGeneric
     */
    'error': GenericError;
}
/**
 * 
 * @export
 * @interface ExpandedPermissionTree
 */
export interface ExpandedPermissionTree {
    /**
     * The children of the node, possibly none.
     * @type {Array<ExpandedPermissionTree>}
     * @memberof ExpandedPermissionTree
     */
    'children'?: Array<ExpandedPermissionTree>;
    /**
     * 
     * @type {Relationship}
     * @memberof ExpandedPermissionTree
     */
    'tuple'?: Relationship;
    /**
     * The type of the node. union TreeNodeUnion exclusion TreeNodeExclusion intersection TreeNodeIntersection leaf TreeNodeLeaf tuple_to_subject_set TreeNodeTupleToSubjectSet computed_subject_set TreeNodeComputedSubjectSet not TreeNodeNot unspecified TreeNodeUnspecified
     * @type {string}
     * @memberof ExpandedPermissionTree
     */
    'type': ExpandedPermissionTreeTypeEnum;
}

export const ExpandedPermissionTreeTypeEnum = {
    Union: 'union',
    Exclusion: 'exclusion',
    Intersection: 'intersection',
    Leaf: 'leaf',
    TupleToSubjectSet: 'tuple_to_subject_set',
    ComputedSubjectSet: 'computed_subject_set',
    Not: 'not',
    Unspecified: 'unspecified',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type ExpandedPermissionTreeTypeEnum = typeof ExpandedPermissionTreeTypeEnum[keyof typeof ExpandedPermissionTreeTypeEnum];

/**
 * 
 * @export
 * @interface GenericError
 */
export interface GenericError {
    /**
     * The status code
     * @type {number}
     * @memberof GenericError
     */
    'code'?: number;
    /**
     * Debug information  This field is often not exposed to protect against leaking sensitive information.
     * @type {string}
     * @memberof GenericError
     */
    'debug'?: string;
    /**
     * Further error details
     * @type {{ [key: string]: any; }}
     * @memberof GenericError
     */
    'details'?: { [key: string]: any; };
    /**
     * The error ID  Useful when trying to identify various errors in application logic.
     * @type {string}
     * @memberof GenericError
     */
    'id'?: string;
    /**
     * Error message  The error\'s message.
     * @type {string}
     * @memberof GenericError
     */
    'message': string;
    /**
     * A human-readable reason for the error
     * @type {string}
     * @memberof GenericError
     */
    'reason'?: string;
    /**
     * The request ID  The request ID is often exposed internally in order to trace errors across service architectures. This is often a UUID.
     * @type {string}
     * @memberof GenericError
     */
    'request'?: string;
    /**
     * The status description
     * @type {string}
     * @memberof GenericError
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetVersion200Response
 */
export interface GetVersion200Response {
    /**
     * The version of Ory Keto.
     * @type {string}
     * @memberof GetVersion200Response
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface HealthNotReadyStatus
 */
export interface HealthNotReadyStatus {
    /**
     * Errors contains a list of errors that caused the not ready status.
     * @type {{ [key: string]: string; }}
     * @memberof HealthNotReadyStatus
     */
    'errors'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface HealthStatus
 */
export interface HealthStatus {
    /**
     * Status always contains \"ok\".
     * @type {string}
     * @memberof HealthStatus
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface IsAlive200Response
 */
export interface IsAlive200Response {
    /**
     * Always \"ok\".
     * @type {string}
     * @memberof IsAlive200Response
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface IsReady503Response
 */
export interface IsReady503Response {
    /**
     * Errors contains a list of errors that caused the not ready status.
     * @type {{ [key: string]: string; }}
     * @memberof IsReady503Response
     */
    'errors': { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface Namespace
 */
export interface Namespace {
    /**
     * Name of the namespace.
     * @type {string}
     * @memberof Namespace
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ParseError
 */
export interface ParseError {
    /**
     * 
     * @type {SourcePosition}
     * @memberof ParseError
     */
    'end'?: SourcePosition;
    /**
     * 
     * @type {string}
     * @memberof ParseError
     */
    'message'?: string;
    /**
     * 
     * @type {SourcePosition}
     * @memberof ParseError
     */
    'start'?: SourcePosition;
}
/**
 * Check Permission using Post Request Body
 * @export
 * @interface PostCheckPermissionBody
 */
export interface PostCheckPermissionBody {
    /**
     * Namespace to query
     * @type {string}
     * @memberof PostCheckPermissionBody
     */
    'namespace'?: string;
    /**
     * Object to query
     * @type {string}
     * @memberof PostCheckPermissionBody
     */
    'object'?: string;
    /**
     * Relation to query
     * @type {string}
     * @memberof PostCheckPermissionBody
     */
    'relation'?: string;
    /**
     * SubjectID to query  Either SubjectSet or SubjectID can be provided.
     * @type {string}
     * @memberof PostCheckPermissionBody
     */
    'subject_id'?: string;
    /**
     * 
     * @type {SubjectSet}
     * @memberof PostCheckPermissionBody
     */
    'subject_set'?: SubjectSet;
}
/**
 * Post Check Permission Or Error Body
 * @export
 * @interface PostCheckPermissionOrErrorBody
 */
export interface PostCheckPermissionOrErrorBody {
    /**
     * Namespace to query
     * @type {string}
     * @memberof PostCheckPermissionOrErrorBody
     */
    'namespace'?: string;
    /**
     * Object to query
     * @type {string}
     * @memberof PostCheckPermissionOrErrorBody
     */
    'object'?: string;
    /**
     * Relation to query
     * @type {string}
     * @memberof PostCheckPermissionOrErrorBody
     */
    'relation'?: string;
    /**
     * SubjectID to query  Either SubjectSet or SubjectID can be provided.
     * @type {string}
     * @memberof PostCheckPermissionOrErrorBody
     */
    'subject_id'?: string;
    /**
     * 
     * @type {SubjectSet}
     * @memberof PostCheckPermissionOrErrorBody
     */
    'subject_set'?: SubjectSet;
}
/**
 * Relation Query
 * @export
 * @interface RelationQuery
 */
export interface RelationQuery {
    /**
     * Namespace to query
     * @type {string}
     * @memberof RelationQuery
     */
    'namespace'?: string;
    /**
     * Object to query
     * @type {string}
     * @memberof RelationQuery
     */
    'object'?: string;
    /**
     * Relation to query
     * @type {string}
     * @memberof RelationQuery
     */
    'relation'?: string;
    /**
     * SubjectID to query  Either SubjectSet or SubjectID can be provided.
     * @type {string}
     * @memberof RelationQuery
     */
    'subject_id'?: string;
    /**
     * 
     * @type {SubjectSet}
     * @memberof RelationQuery
     */
    'subject_set'?: SubjectSet;
}
/**
 * Relationship
 * @export
 * @interface Relationship
 */
export interface Relationship {
    /**
     * Namespace of the Relation Tuple
     * @type {string}
     * @memberof Relationship
     */
    'namespace': string;
    /**
     * Object of the Relation Tuple
     * @type {string}
     * @memberof Relationship
     */
    'object': string;
    /**
     * Relation of the Relation Tuple
     * @type {string}
     * @memberof Relationship
     */
    'relation': string;
    /**
     * SubjectID of the Relation Tuple  Either SubjectSet or SubjectID can be provided.
     * @type {string}
     * @memberof Relationship
     */
    'subject_id'?: string;
    /**
     * 
     * @type {SubjectSet}
     * @memberof Relationship
     */
    'subject_set'?: SubjectSet;
}
/**
 * Relationship Namespace List
 * @export
 * @interface RelationshipNamespaces
 */
export interface RelationshipNamespaces {
    /**
     * 
     * @type {Array<Namespace>}
     * @memberof RelationshipNamespaces
     */
    'namespaces'?: Array<Namespace>;
}
/**
 * Payload for patching a relationship
 * @export
 * @interface RelationshipPatch
 */
export interface RelationshipPatch {
    /**
     * 
     * @type {string}
     * @memberof RelationshipPatch
     */
    'action'?: RelationshipPatchActionEnum;
    /**
     * 
     * @type {Relationship}
     * @memberof RelationshipPatch
     */
    'relation_tuple'?: Relationship;
}

export const RelationshipPatchActionEnum = {
    Insert: 'insert',
    Delete: 'delete',
    UnknownDefaultOpenApi: '11184809'
} as const;

export type RelationshipPatchActionEnum = typeof RelationshipPatchActionEnum[keyof typeof RelationshipPatchActionEnum];

/**
 * Paginated Relationship List
 * @export
 * @interface Relationships
 */
export interface Relationships {
    /**
     * The opaque token to provide in a subsequent request to get the next page. It is the empty string iff this is the last page.
     * @type {string}
     * @memberof Relationships
     */
    'next_page_token'?: string;
    /**
     * 
     * @type {Array<Relationship>}
     * @memberof Relationships
     */
    'relation_tuples'?: Array<Relationship>;
}
/**
 * 
 * @export
 * @interface SourcePosition
 */
export interface SourcePosition {
    /**
     * 
     * @type {number}
     * @memberof SourcePosition
     */
    'Line'?: number;
    /**
     * 
     * @type {number}
     * @memberof SourcePosition
     */
    'column'?: number;
}
/**
 * 
 * @export
 * @interface SubjectSet
 */
export interface SubjectSet {
    /**
     * Namespace of the Subject Set
     * @type {string}
     * @memberof SubjectSet
     */
    'namespace': string;
    /**
     * Object of the Subject Set
     * @type {string}
     * @memberof SubjectSet
     */
    'object': string;
    /**
     * Relation of the Subject Set
     * @type {string}
     * @memberof SubjectSet
     */
    'relation': string;
}
/**
 * 
 * @export
 * @interface Version
 */
export interface Version {
    /**
     * Version is the service\'s version.
     * @type {string}
     * @memberof Version
     */
    'version'?: string;
}

/**
 * MetadataApi - axios parameter creator
 * @export
 */
export const MetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns the version of Ory Keto.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the version will never refer to the cluster state, only to a single instance.
         * @summary Return Running Software Version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a HTTP 200 status code when Ory Keto is accepting incoming HTTP requests. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check HTTP Server Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAlive: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/alive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a HTTP 200 status code when Ory Keto is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of Ory Keto, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check HTTP Server and Database Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isReady: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/ready`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetadataApi - functional programming interface
 * @export
 */
export const MetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns the version of Ory Keto.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the version will never refer to the cluster state, only to a single instance.
         * @summary Return Running Software Version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetVersion200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.getVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint returns a HTTP 200 status code when Ory Keto is accepting incoming HTTP requests. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check HTTP Server Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isAlive(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IsAlive200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isAlive(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.isAlive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint returns a HTTP 200 status code when Ory Keto is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of Ory Keto, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check HTTP Server and Database Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isReady(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IsAlive200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isReady(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.isReady']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetadataApi - factory interface
 * @export
 */
export const MetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetadataApiFp(configuration)
    return {
        /**
         * This endpoint returns the version of Ory Keto.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the version will never refer to the cluster state, only to a single instance.
         * @summary Return Running Software Version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: RawAxiosRequestConfig): AxiosPromise<GetVersion200Response> {
            return localVarFp.getVersion(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a HTTP 200 status code when Ory Keto is accepting incoming HTTP requests. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check HTTP Server Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAlive(options?: RawAxiosRequestConfig): AxiosPromise<IsAlive200Response> {
            return localVarFp.isAlive(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a HTTP 200 status code when Ory Keto is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of Ory Keto, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check HTTP Server and Database Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isReady(options?: RawAxiosRequestConfig): AxiosPromise<IsAlive200Response> {
            return localVarFp.isReady(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
export class MetadataApi extends BaseAPI {
    /**
     * This endpoint returns the version of Ory Keto.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the version will never refer to the cluster state, only to a single instance.
     * @summary Return Running Software Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public getVersion(options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a HTTP 200 status code when Ory Keto is accepting incoming HTTP requests. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
     * @summary Check HTTP Server Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public isAlive(options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).isAlive(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a HTTP 200 status code when Ory Keto is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of Ory Keto, the health status will never refer to the cluster state, only to a single instance.
     * @summary Check HTTP Server and Database Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public isReady(options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).isReady(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PermissionApi - axios parameter creator
 * @export
 */
export const PermissionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
         * @summary Batch check permissions
         * @param {number} [maxDepth] 
         * @param {BatchCheckPermissionBody} [batchCheckPermissionBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchCheckPermission: async (maxDepth?: number, batchCheckPermissionBody?: BatchCheckPermissionBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/relation-tuples/batch/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxDepth !== undefined) {
                localVarQueryParameter['max-depth'] = maxDepth;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(batchCheckPermissionBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
         * @summary Check a permission
         * @param {string} [namespace] Namespace of the Relationship
         * @param {string} [object] Object of the Relationship
         * @param {string} [relation] Relation of the Relationship
         * @param {string} [subjectId] SubjectID of the Relationship
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPermission: async (namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, maxDepth?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/relation-tuples/check/openapi`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subject_id'] = subjectId;
            }

            if (subjectSetNamespace !== undefined) {
                localVarQueryParameter['subject_set.namespace'] = subjectSetNamespace;
            }

            if (subjectSetObject !== undefined) {
                localVarQueryParameter['subject_set.object'] = subjectSetObject;
            }

            if (subjectSetRelation !== undefined) {
                localVarQueryParameter['subject_set.relation'] = subjectSetRelation;
            }

            if (maxDepth !== undefined) {
                localVarQueryParameter['max-depth'] = maxDepth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
         * @summary Check a permission
         * @param {string} [namespace] Namespace of the Relationship
         * @param {string} [object] Object of the Relationship
         * @param {string} [relation] Relation of the Relationship
         * @param {string} [subjectId] SubjectID of the Relationship
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPermissionOrError: async (namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, maxDepth?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/relation-tuples/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subject_id'] = subjectId;
            }

            if (subjectSetNamespace !== undefined) {
                localVarQueryParameter['subject_set.namespace'] = subjectSetNamespace;
            }

            if (subjectSetObject !== undefined) {
                localVarQueryParameter['subject_set.object'] = subjectSetObject;
            }

            if (subjectSetRelation !== undefined) {
                localVarQueryParameter['subject_set.relation'] = subjectSetRelation;
            }

            if (maxDepth !== undefined) {
                localVarQueryParameter['max-depth'] = maxDepth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to expand a relationship tuple into permissions.
         * @summary Expand a Relationship into permissions.
         * @param {string} namespace Namespace of the Subject Set
         * @param {string} object Object of the Subject Set
         * @param {string} relation Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expandPermissions: async (namespace: string, object: string, relation: string, maxDepth?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('expandPermissions', 'namespace', namespace)
            // verify required parameter 'object' is not null or undefined
            assertParamExists('expandPermissions', 'object', object)
            // verify required parameter 'relation' is not null or undefined
            assertParamExists('expandPermissions', 'relation', relation)
            const localVarPath = `/relation-tuples/expand`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }

            if (maxDepth !== undefined) {
                localVarQueryParameter['max-depth'] = maxDepth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
         * @summary Check a permission
         * @param {number} [maxDepth] 
         * @param {PostCheckPermissionBody} [postCheckPermissionBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCheckPermission: async (maxDepth?: number, postCheckPermissionBody?: PostCheckPermissionBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/relation-tuples/check/openapi`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxDepth !== undefined) {
                localVarQueryParameter['max-depth'] = maxDepth;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postCheckPermissionBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
         * @summary Check a permission
         * @param {number} [maxDepth] 
         * @param {PostCheckPermissionOrErrorBody} [postCheckPermissionOrErrorBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCheckPermissionOrError: async (maxDepth?: number, postCheckPermissionOrErrorBody?: PostCheckPermissionOrErrorBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/relation-tuples/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxDepth !== undefined) {
                localVarQueryParameter['max-depth'] = maxDepth;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postCheckPermissionOrErrorBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PermissionApi - functional programming interface
 * @export
 */
export const PermissionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PermissionApiAxiosParamCreator(configuration)
    return {
        /**
         * To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
         * @summary Batch check permissions
         * @param {number} [maxDepth] 
         * @param {BatchCheckPermissionBody} [batchCheckPermissionBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async batchCheckPermission(maxDepth?: number, batchCheckPermissionBody?: BatchCheckPermissionBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchCheckPermissionResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.batchCheckPermission(maxDepth, batchCheckPermissionBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionApi.batchCheckPermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
         * @summary Check a permission
         * @param {string} [namespace] Namespace of the Relationship
         * @param {string} [object] Object of the Relationship
         * @param {string} [relation] Relation of the Relationship
         * @param {string} [subjectId] SubjectID of the Relationship
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkPermission(namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, maxDepth?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckPermissionResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkPermission(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, maxDepth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionApi.checkPermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
         * @summary Check a permission
         * @param {string} [namespace] Namespace of the Relationship
         * @param {string} [object] Object of the Relationship
         * @param {string} [relation] Relation of the Relationship
         * @param {string} [subjectId] SubjectID of the Relationship
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkPermissionOrError(namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, maxDepth?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckPermissionResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkPermissionOrError(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, maxDepth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionApi.checkPermissionOrError']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to expand a relationship tuple into permissions.
         * @summary Expand a Relationship into permissions.
         * @param {string} namespace Namespace of the Subject Set
         * @param {string} object Object of the Subject Set
         * @param {string} relation Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async expandPermissions(namespace: string, object: string, relation: string, maxDepth?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpandedPermissionTree>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.expandPermissions(namespace, object, relation, maxDepth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionApi.expandPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
         * @summary Check a permission
         * @param {number} [maxDepth] 
         * @param {PostCheckPermissionBody} [postCheckPermissionBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCheckPermission(maxDepth?: number, postCheckPermissionBody?: PostCheckPermissionBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckPermissionResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCheckPermission(maxDepth, postCheckPermissionBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionApi.postCheckPermission']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
         * @summary Check a permission
         * @param {number} [maxDepth] 
         * @param {PostCheckPermissionOrErrorBody} [postCheckPermissionOrErrorBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCheckPermissionOrError(maxDepth?: number, postCheckPermissionOrErrorBody?: PostCheckPermissionOrErrorBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckPermissionResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCheckPermissionOrError(maxDepth, postCheckPermissionOrErrorBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PermissionApi.postCheckPermissionOrError']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PermissionApi - factory interface
 * @export
 */
export const PermissionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PermissionApiFp(configuration)
    return {
        /**
         * To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
         * @summary Batch check permissions
         * @param {PermissionApiBatchCheckPermissionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        batchCheckPermission(requestParameters: PermissionApiBatchCheckPermissionRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<BatchCheckPermissionResult> {
            return localVarFp.batchCheckPermission(requestParameters.maxDepth, requestParameters.batchCheckPermissionBody, options).then((request) => request(axios, basePath));
        },
        /**
         * To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
         * @summary Check a permission
         * @param {PermissionApiCheckPermissionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPermission(requestParameters: PermissionApiCheckPermissionRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CheckPermissionResult> {
            return localVarFp.checkPermission(requestParameters.namespace, requestParameters.object, requestParameters.relation, requestParameters.subjectId, requestParameters.subjectSetNamespace, requestParameters.subjectSetObject, requestParameters.subjectSetRelation, requestParameters.maxDepth, options).then((request) => request(axios, basePath));
        },
        /**
         * To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
         * @summary Check a permission
         * @param {PermissionApiCheckPermissionOrErrorRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPermissionOrError(requestParameters: PermissionApiCheckPermissionOrErrorRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CheckPermissionResult> {
            return localVarFp.checkPermissionOrError(requestParameters.namespace, requestParameters.object, requestParameters.relation, requestParameters.subjectId, requestParameters.subjectSetNamespace, requestParameters.subjectSetObject, requestParameters.subjectSetRelation, requestParameters.maxDepth, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to expand a relationship tuple into permissions.
         * @summary Expand a Relationship into permissions.
         * @param {PermissionApiExpandPermissionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        expandPermissions(requestParameters: PermissionApiExpandPermissionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<ExpandedPermissionTree> {
            return localVarFp.expandPermissions(requestParameters.namespace, requestParameters.object, requestParameters.relation, requestParameters.maxDepth, options).then((request) => request(axios, basePath));
        },
        /**
         * To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
         * @summary Check a permission
         * @param {PermissionApiPostCheckPermissionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCheckPermission(requestParameters: PermissionApiPostCheckPermissionRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CheckPermissionResult> {
            return localVarFp.postCheckPermission(requestParameters.maxDepth, requestParameters.postCheckPermissionBody, options).then((request) => request(axios, basePath));
        },
        /**
         * To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
         * @summary Check a permission
         * @param {PermissionApiPostCheckPermissionOrErrorRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCheckPermissionOrError(requestParameters: PermissionApiPostCheckPermissionOrErrorRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CheckPermissionResult> {
            return localVarFp.postCheckPermissionOrError(requestParameters.maxDepth, requestParameters.postCheckPermissionOrErrorBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for batchCheckPermission operation in PermissionApi.
 * @export
 * @interface PermissionApiBatchCheckPermissionRequest
 */
export interface PermissionApiBatchCheckPermissionRequest {
    /**
     * 
     * @type {number}
     * @memberof PermissionApiBatchCheckPermission
     */
    readonly maxDepth?: number

    /**
     * 
     * @type {BatchCheckPermissionBody}
     * @memberof PermissionApiBatchCheckPermission
     */
    readonly batchCheckPermissionBody?: BatchCheckPermissionBody
}

/**
 * Request parameters for checkPermission operation in PermissionApi.
 * @export
 * @interface PermissionApiCheckPermissionRequest
 */
export interface PermissionApiCheckPermissionRequest {
    /**
     * Namespace of the Relationship
     * @type {string}
     * @memberof PermissionApiCheckPermission
     */
    readonly namespace?: string

    /**
     * Object of the Relationship
     * @type {string}
     * @memberof PermissionApiCheckPermission
     */
    readonly object?: string

    /**
     * Relation of the Relationship
     * @type {string}
     * @memberof PermissionApiCheckPermission
     */
    readonly relation?: string

    /**
     * SubjectID of the Relationship
     * @type {string}
     * @memberof PermissionApiCheckPermission
     */
    readonly subjectId?: string

    /**
     * Namespace of the Subject Set
     * @type {string}
     * @memberof PermissionApiCheckPermission
     */
    readonly subjectSetNamespace?: string

    /**
     * Object of the Subject Set
     * @type {string}
     * @memberof PermissionApiCheckPermission
     */
    readonly subjectSetObject?: string

    /**
     * Relation of the Subject Set
     * @type {string}
     * @memberof PermissionApiCheckPermission
     */
    readonly subjectSetRelation?: string

    /**
     * 
     * @type {number}
     * @memberof PermissionApiCheckPermission
     */
    readonly maxDepth?: number
}

/**
 * Request parameters for checkPermissionOrError operation in PermissionApi.
 * @export
 * @interface PermissionApiCheckPermissionOrErrorRequest
 */
export interface PermissionApiCheckPermissionOrErrorRequest {
    /**
     * Namespace of the Relationship
     * @type {string}
     * @memberof PermissionApiCheckPermissionOrError
     */
    readonly namespace?: string

    /**
     * Object of the Relationship
     * @type {string}
     * @memberof PermissionApiCheckPermissionOrError
     */
    readonly object?: string

    /**
     * Relation of the Relationship
     * @type {string}
     * @memberof PermissionApiCheckPermissionOrError
     */
    readonly relation?: string

    /**
     * SubjectID of the Relationship
     * @type {string}
     * @memberof PermissionApiCheckPermissionOrError
     */
    readonly subjectId?: string

    /**
     * Namespace of the Subject Set
     * @type {string}
     * @memberof PermissionApiCheckPermissionOrError
     */
    readonly subjectSetNamespace?: string

    /**
     * Object of the Subject Set
     * @type {string}
     * @memberof PermissionApiCheckPermissionOrError
     */
    readonly subjectSetObject?: string

    /**
     * Relation of the Subject Set
     * @type {string}
     * @memberof PermissionApiCheckPermissionOrError
     */
    readonly subjectSetRelation?: string

    /**
     * 
     * @type {number}
     * @memberof PermissionApiCheckPermissionOrError
     */
    readonly maxDepth?: number
}

/**
 * Request parameters for expandPermissions operation in PermissionApi.
 * @export
 * @interface PermissionApiExpandPermissionsRequest
 */
export interface PermissionApiExpandPermissionsRequest {
    /**
     * Namespace of the Subject Set
     * @type {string}
     * @memberof PermissionApiExpandPermissions
     */
    readonly namespace: string

    /**
     * Object of the Subject Set
     * @type {string}
     * @memberof PermissionApiExpandPermissions
     */
    readonly object: string

    /**
     * Relation of the Subject Set
     * @type {string}
     * @memberof PermissionApiExpandPermissions
     */
    readonly relation: string

    /**
     * 
     * @type {number}
     * @memberof PermissionApiExpandPermissions
     */
    readonly maxDepth?: number
}

/**
 * Request parameters for postCheckPermission operation in PermissionApi.
 * @export
 * @interface PermissionApiPostCheckPermissionRequest
 */
export interface PermissionApiPostCheckPermissionRequest {
    /**
     * 
     * @type {number}
     * @memberof PermissionApiPostCheckPermission
     */
    readonly maxDepth?: number

    /**
     * 
     * @type {PostCheckPermissionBody}
     * @memberof PermissionApiPostCheckPermission
     */
    readonly postCheckPermissionBody?: PostCheckPermissionBody
}

/**
 * Request parameters for postCheckPermissionOrError operation in PermissionApi.
 * @export
 * @interface PermissionApiPostCheckPermissionOrErrorRequest
 */
export interface PermissionApiPostCheckPermissionOrErrorRequest {
    /**
     * 
     * @type {number}
     * @memberof PermissionApiPostCheckPermissionOrError
     */
    readonly maxDepth?: number

    /**
     * 
     * @type {PostCheckPermissionOrErrorBody}
     * @memberof PermissionApiPostCheckPermissionOrError
     */
    readonly postCheckPermissionOrErrorBody?: PostCheckPermissionOrErrorBody
}

/**
 * PermissionApi - object-oriented interface
 * @export
 * @class PermissionApi
 * @extends {BaseAPI}
 */
export class PermissionApi extends BaseAPI {
    /**
     * To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
     * @summary Batch check permissions
     * @param {PermissionApiBatchCheckPermissionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public batchCheckPermission(requestParameters: PermissionApiBatchCheckPermissionRequest = {}, options?: RawAxiosRequestConfig) {
        return PermissionApiFp(this.configuration).batchCheckPermission(requestParameters.maxDepth, requestParameters.batchCheckPermissionBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
     * @summary Check a permission
     * @param {PermissionApiCheckPermissionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public checkPermission(requestParameters: PermissionApiCheckPermissionRequest = {}, options?: RawAxiosRequestConfig) {
        return PermissionApiFp(this.configuration).checkPermission(requestParameters.namespace, requestParameters.object, requestParameters.relation, requestParameters.subjectId, requestParameters.subjectSetNamespace, requestParameters.subjectSetObject, requestParameters.subjectSetRelation, requestParameters.maxDepth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
     * @summary Check a permission
     * @param {PermissionApiCheckPermissionOrErrorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public checkPermissionOrError(requestParameters: PermissionApiCheckPermissionOrErrorRequest = {}, options?: RawAxiosRequestConfig) {
        return PermissionApiFp(this.configuration).checkPermissionOrError(requestParameters.namespace, requestParameters.object, requestParameters.relation, requestParameters.subjectId, requestParameters.subjectSetNamespace, requestParameters.subjectSetObject, requestParameters.subjectSetRelation, requestParameters.maxDepth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to expand a relationship tuple into permissions.
     * @summary Expand a Relationship into permissions.
     * @param {PermissionApiExpandPermissionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public expandPermissions(requestParameters: PermissionApiExpandPermissionsRequest, options?: RawAxiosRequestConfig) {
        return PermissionApiFp(this.configuration).expandPermissions(requestParameters.namespace, requestParameters.object, requestParameters.relation, requestParameters.maxDepth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
     * @summary Check a permission
     * @param {PermissionApiPostCheckPermissionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public postCheckPermission(requestParameters: PermissionApiPostCheckPermissionRequest = {}, options?: RawAxiosRequestConfig) {
        return PermissionApiFp(this.configuration).postCheckPermission(requestParameters.maxDepth, requestParameters.postCheckPermissionBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To learn how relationship tuples and the check works, head over to [the documentation](https://www.ory.sh/docs/keto/concepts/api-overview).
     * @summary Check a permission
     * @param {PermissionApiPostCheckPermissionOrErrorRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PermissionApi
     */
    public postCheckPermissionOrError(requestParameters: PermissionApiPostCheckPermissionOrErrorRequest = {}, options?: RawAxiosRequestConfig) {
        return PermissionApiFp(this.configuration).postCheckPermissionOrError(requestParameters.maxDepth, requestParameters.postCheckPermissionOrErrorBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RelationshipApi - axios parameter creator
 * @export
 */
export const RelationshipApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The OPL file is expected in the body of the request.
         * @summary Check the syntax of an OPL file
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkOplSyntax: async (body?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/opl/syntax/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'text/plain';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to create a relationship.
         * @summary Create a Relationship
         * @param {CreateRelationshipBody} [createRelationshipBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelationship: async (createRelationshipBody?: CreateRelationshipBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/relation-tuples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRelationshipBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete relationships
         * @summary Delete Relationships
         * @param {string} [namespace] Namespace of the Relationship
         * @param {string} [object] Object of the Relationship
         * @param {string} [relation] Relation of the Relationship
         * @param {string} [subjectId] SubjectID of the Relationship
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelationships: async (namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/relation-tuples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subject_id'] = subjectId;
            }

            if (subjectSetNamespace !== undefined) {
                localVarQueryParameter['subject_set.namespace'] = subjectSetNamespace;
            }

            if (subjectSetObject !== undefined) {
                localVarQueryParameter['subject_set.object'] = subjectSetObject;
            }

            if (subjectSetRelation !== undefined) {
                localVarQueryParameter['subject_set.relation'] = subjectSetRelation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all relationships that match the query. Only the namespace field is required.
         * @summary Query relationships
         * @param {number} [pageSize] Items per Page  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
         * @param {string} [pageToken] Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
         * @param {string} [namespace] Namespace of the Relationship
         * @param {string} [object] Object of the Relationship
         * @param {string} [relation] Relation of the Relationship
         * @param {string} [subjectId] SubjectID of the Relationship
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationships: async (pageSize?: number, pageToken?: string, namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/relation-tuples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subject_id'] = subjectId;
            }

            if (subjectSetNamespace !== undefined) {
                localVarQueryParameter['subject_set.namespace'] = subjectSetNamespace;
            }

            if (subjectSetObject !== undefined) {
                localVarQueryParameter['subject_set.object'] = subjectSetObject;
            }

            if (subjectSetRelation !== undefined) {
                localVarQueryParameter['subject_set.relation'] = subjectSetRelation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all namespaces
         * @summary Query namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRelationshipNamespaces: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to patch one or more relationships.
         * @summary Patch Multiple Relationships
         * @param {Array<RelationshipPatch>} [relationshipPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRelationships: async (relationshipPatch?: Array<RelationshipPatch>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/relation-tuples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(relationshipPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RelationshipApi - functional programming interface
 * @export
 */
export const RelationshipApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RelationshipApiAxiosParamCreator(configuration)
    return {
        /**
         * The OPL file is expected in the body of the request.
         * @summary Check the syntax of an OPL file
         * @param {string} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkOplSyntax(body?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CheckOplSyntaxResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkOplSyntax(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelationshipApi.checkOplSyntax']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to create a relationship.
         * @summary Create a Relationship
         * @param {CreateRelationshipBody} [createRelationshipBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRelationship(createRelationshipBody?: CreateRelationshipBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Relationship>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRelationship(createRelationshipBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelationshipApi.createRelationship']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to delete relationships
         * @summary Delete Relationships
         * @param {string} [namespace] Namespace of the Relationship
         * @param {string} [object] Object of the Relationship
         * @param {string} [relation] Relation of the Relationship
         * @param {string} [subjectId] SubjectID of the Relationship
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRelationships(namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRelationships(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelationshipApi.deleteRelationships']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all relationships that match the query. Only the namespace field is required.
         * @summary Query relationships
         * @param {number} [pageSize] Items per Page  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
         * @param {string} [pageToken] Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
         * @param {string} [namespace] Namespace of the Relationship
         * @param {string} [object] Object of the Relationship
         * @param {string} [relation] Relation of the Relationship
         * @param {string} [subjectId] SubjectID of the Relationship
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelationships(pageSize?: number, pageToken?: string, namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Relationships>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelationships(pageSize, pageToken, namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelationshipApi.getRelationships']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all namespaces
         * @summary Query namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRelationshipNamespaces(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelationshipNamespaces>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRelationshipNamespaces(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelationshipApi.listRelationshipNamespaces']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use this endpoint to patch one or more relationships.
         * @summary Patch Multiple Relationships
         * @param {Array<RelationshipPatch>} [relationshipPatch] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRelationships(relationshipPatch?: Array<RelationshipPatch>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRelationships(relationshipPatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RelationshipApi.patchRelationships']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RelationshipApi - factory interface
 * @export
 */
export const RelationshipApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RelationshipApiFp(configuration)
    return {
        /**
         * The OPL file is expected in the body of the request.
         * @summary Check the syntax of an OPL file
         * @param {RelationshipApiCheckOplSyntaxRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkOplSyntax(requestParameters: RelationshipApiCheckOplSyntaxRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CheckOplSyntaxResult> {
            return localVarFp.checkOplSyntax(requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to create a relationship.
         * @summary Create a Relationship
         * @param {RelationshipApiCreateRelationshipRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelationship(requestParameters: RelationshipApiCreateRelationshipRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Relationship> {
            return localVarFp.createRelationship(requestParameters.createRelationshipBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete relationships
         * @summary Delete Relationships
         * @param {RelationshipApiDeleteRelationshipsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelationships(requestParameters: RelationshipApiDeleteRelationshipsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRelationships(requestParameters.namespace, requestParameters.object, requestParameters.relation, requestParameters.subjectId, requestParameters.subjectSetNamespace, requestParameters.subjectSetObject, requestParameters.subjectSetRelation, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all relationships that match the query. Only the namespace field is required.
         * @summary Query relationships
         * @param {RelationshipApiGetRelationshipsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationships(requestParameters: RelationshipApiGetRelationshipsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Relationships> {
            return localVarFp.getRelationships(requestParameters.pageSize, requestParameters.pageToken, requestParameters.namespace, requestParameters.object, requestParameters.relation, requestParameters.subjectId, requestParameters.subjectSetNamespace, requestParameters.subjectSetObject, requestParameters.subjectSetRelation, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all namespaces
         * @summary Query namespaces
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRelationshipNamespaces(options?: RawAxiosRequestConfig): AxiosPromise<RelationshipNamespaces> {
            return localVarFp.listRelationshipNamespaces(options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to patch one or more relationships.
         * @summary Patch Multiple Relationships
         * @param {RelationshipApiPatchRelationshipsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRelationships(requestParameters: RelationshipApiPatchRelationshipsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.patchRelationships(requestParameters.relationshipPatch, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for checkOplSyntax operation in RelationshipApi.
 * @export
 * @interface RelationshipApiCheckOplSyntaxRequest
 */
export interface RelationshipApiCheckOplSyntaxRequest {
    /**
     * 
     * @type {string}
     * @memberof RelationshipApiCheckOplSyntax
     */
    readonly body?: string
}

/**
 * Request parameters for createRelationship operation in RelationshipApi.
 * @export
 * @interface RelationshipApiCreateRelationshipRequest
 */
export interface RelationshipApiCreateRelationshipRequest {
    /**
     * 
     * @type {CreateRelationshipBody}
     * @memberof RelationshipApiCreateRelationship
     */
    readonly createRelationshipBody?: CreateRelationshipBody
}

/**
 * Request parameters for deleteRelationships operation in RelationshipApi.
 * @export
 * @interface RelationshipApiDeleteRelationshipsRequest
 */
export interface RelationshipApiDeleteRelationshipsRequest {
    /**
     * Namespace of the Relationship
     * @type {string}
     * @memberof RelationshipApiDeleteRelationships
     */
    readonly namespace?: string

    /**
     * Object of the Relationship
     * @type {string}
     * @memberof RelationshipApiDeleteRelationships
     */
    readonly object?: string

    /**
     * Relation of the Relationship
     * @type {string}
     * @memberof RelationshipApiDeleteRelationships
     */
    readonly relation?: string

    /**
     * SubjectID of the Relationship
     * @type {string}
     * @memberof RelationshipApiDeleteRelationships
     */
    readonly subjectId?: string

    /**
     * Namespace of the Subject Set
     * @type {string}
     * @memberof RelationshipApiDeleteRelationships
     */
    readonly subjectSetNamespace?: string

    /**
     * Object of the Subject Set
     * @type {string}
     * @memberof RelationshipApiDeleteRelationships
     */
    readonly subjectSetObject?: string

    /**
     * Relation of the Subject Set
     * @type {string}
     * @memberof RelationshipApiDeleteRelationships
     */
    readonly subjectSetRelation?: string
}

/**
 * Request parameters for getRelationships operation in RelationshipApi.
 * @export
 * @interface RelationshipApiGetRelationshipsRequest
 */
export interface RelationshipApiGetRelationshipsRequest {
    /**
     * Items per Page  This is the number of items per page to return. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
     * @type {number}
     * @memberof RelationshipApiGetRelationships
     */
    readonly pageSize?: number

    /**
     * Next Page Token  The next page token. For details on pagination please head over to the [pagination documentation](https://www.ory.sh/docs/ecosystem/api-design#pagination).
     * @type {string}
     * @memberof RelationshipApiGetRelationships
     */
    readonly pageToken?: string

    /**
     * Namespace of the Relationship
     * @type {string}
     * @memberof RelationshipApiGetRelationships
     */
    readonly namespace?: string

    /**
     * Object of the Relationship
     * @type {string}
     * @memberof RelationshipApiGetRelationships
     */
    readonly object?: string

    /**
     * Relation of the Relationship
     * @type {string}
     * @memberof RelationshipApiGetRelationships
     */
    readonly relation?: string

    /**
     * SubjectID of the Relationship
     * @type {string}
     * @memberof RelationshipApiGetRelationships
     */
    readonly subjectId?: string

    /**
     * Namespace of the Subject Set
     * @type {string}
     * @memberof RelationshipApiGetRelationships
     */
    readonly subjectSetNamespace?: string

    /**
     * Object of the Subject Set
     * @type {string}
     * @memberof RelationshipApiGetRelationships
     */
    readonly subjectSetObject?: string

    /**
     * Relation of the Subject Set
     * @type {string}
     * @memberof RelationshipApiGetRelationships
     */
    readonly subjectSetRelation?: string
}

/**
 * Request parameters for patchRelationships operation in RelationshipApi.
 * @export
 * @interface RelationshipApiPatchRelationshipsRequest
 */
export interface RelationshipApiPatchRelationshipsRequest {
    /**
     * 
     * @type {Array<RelationshipPatch>}
     * @memberof RelationshipApiPatchRelationships
     */
    readonly relationshipPatch?: Array<RelationshipPatch>
}

/**
 * RelationshipApi - object-oriented interface
 * @export
 * @class RelationshipApi
 * @extends {BaseAPI}
 */
export class RelationshipApi extends BaseAPI {
    /**
     * The OPL file is expected in the body of the request.
     * @summary Check the syntax of an OPL file
     * @param {RelationshipApiCheckOplSyntaxRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationshipApi
     */
    public checkOplSyntax(requestParameters: RelationshipApiCheckOplSyntaxRequest = {}, options?: RawAxiosRequestConfig) {
        return RelationshipApiFp(this.configuration).checkOplSyntax(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to create a relationship.
     * @summary Create a Relationship
     * @param {RelationshipApiCreateRelationshipRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationshipApi
     */
    public createRelationship(requestParameters: RelationshipApiCreateRelationshipRequest = {}, options?: RawAxiosRequestConfig) {
        return RelationshipApiFp(this.configuration).createRelationship(requestParameters.createRelationshipBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete relationships
     * @summary Delete Relationships
     * @param {RelationshipApiDeleteRelationshipsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationshipApi
     */
    public deleteRelationships(requestParameters: RelationshipApiDeleteRelationshipsRequest = {}, options?: RawAxiosRequestConfig) {
        return RelationshipApiFp(this.configuration).deleteRelationships(requestParameters.namespace, requestParameters.object, requestParameters.relation, requestParameters.subjectId, requestParameters.subjectSetNamespace, requestParameters.subjectSetObject, requestParameters.subjectSetRelation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all relationships that match the query. Only the namespace field is required.
     * @summary Query relationships
     * @param {RelationshipApiGetRelationshipsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationshipApi
     */
    public getRelationships(requestParameters: RelationshipApiGetRelationshipsRequest = {}, options?: RawAxiosRequestConfig) {
        return RelationshipApiFp(this.configuration).getRelationships(requestParameters.pageSize, requestParameters.pageToken, requestParameters.namespace, requestParameters.object, requestParameters.relation, requestParameters.subjectId, requestParameters.subjectSetNamespace, requestParameters.subjectSetObject, requestParameters.subjectSetRelation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all namespaces
     * @summary Query namespaces
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationshipApi
     */
    public listRelationshipNamespaces(options?: RawAxiosRequestConfig) {
        return RelationshipApiFp(this.configuration).listRelationshipNamespaces(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to patch one or more relationships.
     * @summary Patch Multiple Relationships
     * @param {RelationshipApiPatchRelationshipsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RelationshipApi
     */
    public patchRelationships(requestParameters: RelationshipApiPatchRelationshipsRequest = {}, options?: RawAxiosRequestConfig) {
        return RelationshipApiFp(this.configuration).patchRelationships(requestParameters.relationshipPatch, options).then((request) => request(this.axios, this.basePath));
    }
}



