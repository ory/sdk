/* tslint:disable */
/* eslint-disable */
/**
 * ORY Keto
 * A cloud native access control server providing best-practice patterns (RBAC, ABAC, ACL, AWS IAM Policies, Kubernetes Roles, ...) via REST APIs.
 *
 * The version of the OpenAPI document: v0.0.0
 * Contact: hi@ory.sh
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * AddOryAccessControlPolicyRoleMembers add ory access control policy role members
 * @export
 * @interface AddOryAccessControlPolicyRoleMembers
 */
export interface AddOryAccessControlPolicyRoleMembers {
    /**
     * 
     * @type {AddOryAccessControlPolicyRoleMembersBody}
     * @memberof AddOryAccessControlPolicyRoleMembers
     */
    Body?: AddOryAccessControlPolicyRoleMembersBody;
    /**
     * The ORY Access Control Policy flavor. Can be \"regex\", \"glob\", and \"exact\".  in: path
     * @type {string}
     * @memberof AddOryAccessControlPolicyRoleMembers
     */
    flavor: string;
    /**
     * The ID of the ORY Access Control Policy Role.  in: path
     * @type {string}
     * @memberof AddOryAccessControlPolicyRoleMembers
     */
    id: string;
}
/**
 * 
 * @export
 * @interface AddOryAccessControlPolicyRoleMembersBody
 */
export interface AddOryAccessControlPolicyRoleMembersBody {
    /**
     * The members to be added.
     * @type {Array<string>}
     * @memberof AddOryAccessControlPolicyRoleMembersBody
     */
    members?: Array<string>;
}
/**
 * The standard error format
 * @export
 * @interface AddOryAccessControlPolicyRoleMembersInternalServerError
 */
export interface AddOryAccessControlPolicyRoleMembersInternalServerError {
    /**
     * 
     * @type {AddOryAccessControlPolicyRoleMembersInternalServerErrorBody}
     * @memberof AddOryAccessControlPolicyRoleMembersInternalServerError
     */
    Payload?: AddOryAccessControlPolicyRoleMembersInternalServerErrorBody;
}
/**
 * AddOryAccessControlPolicyRoleMembersInternalServerErrorBody add ory access control policy role members internal server error body
 * @export
 * @interface AddOryAccessControlPolicyRoleMembersInternalServerErrorBody
 */
export interface AddOryAccessControlPolicyRoleMembersInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof AddOryAccessControlPolicyRoleMembersInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof AddOryAccessControlPolicyRoleMembersInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof AddOryAccessControlPolicyRoleMembersInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof AddOryAccessControlPolicyRoleMembersInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof AddOryAccessControlPolicyRoleMembersInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof AddOryAccessControlPolicyRoleMembersInternalServerErrorBody
     */
    status?: string;
}
/**
 * oryAccessControlPolicyRole
 * @export
 * @interface AddOryAccessControlPolicyRoleMembersOK
 */
export interface AddOryAccessControlPolicyRoleMembersOK {
    /**
     * 
     * @type {OryAccessControlPolicyRole}
     * @memberof AddOryAccessControlPolicyRoleMembersOK
     */
    Payload?: OryAccessControlPolicyRole;
}
/**
 * 
 * @export
 * @interface AuthorizationResult
 */
export interface AuthorizationResult {
    /**
     * Allowed is true if the request should be allowed and false otherwise.
     * @type {boolean}
     * @memberof AuthorizationResult
     */
    allowed: boolean;
}
/**
 * DeleteOryAccessControlPolicy delete ory access control policy
 * @export
 * @interface DeleteOryAccessControlPolicy
 */
export interface DeleteOryAccessControlPolicy {
    /**
     * The ORY Access Control Policy flavor. Can be \"regex\", \"glob\", and \"exact\".  in: path
     * @type {string}
     * @memberof DeleteOryAccessControlPolicy
     */
    flavor: string;
    /**
     * The ID of the ORY Access Control Policy Role.  in: path
     * @type {string}
     * @memberof DeleteOryAccessControlPolicy
     */
    id: string;
}
/**
 * The standard error format
 * @export
 * @interface DeleteOryAccessControlPolicyInternalServerError
 */
export interface DeleteOryAccessControlPolicyInternalServerError {
    /**
     * 
     * @type {DeleteOryAccessControlPolicyInternalServerErrorBody}
     * @memberof DeleteOryAccessControlPolicyInternalServerError
     */
    Payload?: DeleteOryAccessControlPolicyInternalServerErrorBody;
}
/**
 * DeleteOryAccessControlPolicyInternalServerErrorBody DeleteOryAccessControlPolicyInternalServerErrorBody delete ory access control policy internal server error body
 * @export
 * @interface DeleteOryAccessControlPolicyInternalServerErrorBody
 */
export interface DeleteOryAccessControlPolicyInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof DeleteOryAccessControlPolicyInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof DeleteOryAccessControlPolicyInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof DeleteOryAccessControlPolicyInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof DeleteOryAccessControlPolicyInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof DeleteOryAccessControlPolicyInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof DeleteOryAccessControlPolicyInternalServerErrorBody
     */
    status?: string;
}
/**
 * DeleteOryAccessControlPolicyRole delete ory access control policy role
 * @export
 * @interface DeleteOryAccessControlPolicyRole
 */
export interface DeleteOryAccessControlPolicyRole {
    /**
     * The ORY Access Control Policy flavor. Can be \"regex\", \"glob\", and \"exact\".  in: path
     * @type {string}
     * @memberof DeleteOryAccessControlPolicyRole
     */
    flavor: string;
    /**
     * The ID of the ORY Access Control Policy Role. in: path
     * @type {string}
     * @memberof DeleteOryAccessControlPolicyRole
     */
    id: string;
}
/**
 * The standard error format
 * @export
 * @interface DeleteOryAccessControlPolicyRoleInternalServerError
 */
export interface DeleteOryAccessControlPolicyRoleInternalServerError {
    /**
     * 
     * @type {DeleteOryAccessControlPolicyRoleInternalServerErrorBody}
     * @memberof DeleteOryAccessControlPolicyRoleInternalServerError
     */
    Payload?: DeleteOryAccessControlPolicyRoleInternalServerErrorBody;
}
/**
 * DeleteOryAccessControlPolicyRoleInternalServerErrorBody delete ory access control policy role internal server error body
 * @export
 * @interface DeleteOryAccessControlPolicyRoleInternalServerErrorBody
 */
export interface DeleteOryAccessControlPolicyRoleInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof DeleteOryAccessControlPolicyRoleInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof DeleteOryAccessControlPolicyRoleInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof DeleteOryAccessControlPolicyRoleInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof DeleteOryAccessControlPolicyRoleInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof DeleteOryAccessControlPolicyRoleInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof DeleteOryAccessControlPolicyRoleInternalServerErrorBody
     */
    status?: string;
}
/**
 * DoOryAccessControlPoliciesAllow do ory access control policies allow
 * @export
 * @interface DoOryAccessControlPoliciesAllow
 */
export interface DoOryAccessControlPoliciesAllow {
    /**
     * 
     * @type {OryAccessControlPolicyAllowedInput}
     * @memberof DoOryAccessControlPoliciesAllow
     */
    Body?: OryAccessControlPolicyAllowedInput;
    /**
     * The ORY Access Control Policy flavor. Can be \"regex\", \"glob\", and \"exact\".  in: path
     * @type {string}
     * @memberof DoOryAccessControlPoliciesAllow
     */
    flavor: string;
}
/**
 * authorizationResult
 * @export
 * @interface DoOryAccessControlPoliciesAllowForbidden
 */
export interface DoOryAccessControlPoliciesAllowForbidden {
    /**
     * 
     * @type {AuthorizationResult}
     * @memberof DoOryAccessControlPoliciesAllowForbidden
     */
    Payload?: AuthorizationResult;
}
/**
 * The standard error format
 * @export
 * @interface DoOryAccessControlPoliciesAllowInternalServerError
 */
export interface DoOryAccessControlPoliciesAllowInternalServerError {
    /**
     * 
     * @type {DoOryAccessControlPoliciesAllowInternalServerErrorBody}
     * @memberof DoOryAccessControlPoliciesAllowInternalServerError
     */
    Payload?: DoOryAccessControlPoliciesAllowInternalServerErrorBody;
}
/**
 * DoOryAccessControlPoliciesAllowInternalServerErrorBody DoOryAccessControlPoliciesAllowInternalServerErrorBody do ory access control policies allow internal server error body
 * @export
 * @interface DoOryAccessControlPoliciesAllowInternalServerErrorBody
 */
export interface DoOryAccessControlPoliciesAllowInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof DoOryAccessControlPoliciesAllowInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof DoOryAccessControlPoliciesAllowInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof DoOryAccessControlPoliciesAllowInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof DoOryAccessControlPoliciesAllowInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof DoOryAccessControlPoliciesAllowInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof DoOryAccessControlPoliciesAllowInternalServerErrorBody
     */
    status?: string;
}
/**
 * authorizationResult
 * @export
 * @interface DoOryAccessControlPoliciesAllowOK
 */
export interface DoOryAccessControlPoliciesAllowOK {
    /**
     * 
     * @type {AuthorizationResult}
     * @memberof DoOryAccessControlPoliciesAllowOK
     */
    Payload?: AuthorizationResult;
}
/**
 * GetOryAccessControlPolicy get ory access control policy
 * @export
 * @interface GetOryAccessControlPolicy
 */
export interface GetOryAccessControlPolicy {
    /**
     * The ORY Access Control Policy flavor. Can be \"regex\", \"glob\", and \"exact\".  in: path
     * @type {string}
     * @memberof GetOryAccessControlPolicy
     */
    flavor: string;
    /**
     * The ID of the ORY Access Control Policy Role.  in: path
     * @type {string}
     * @memberof GetOryAccessControlPolicy
     */
    id: string;
}
/**
 * The standard error format
 * @export
 * @interface GetOryAccessControlPolicyInternalServerError
 */
export interface GetOryAccessControlPolicyInternalServerError {
    /**
     * 
     * @type {GetOryAccessControlPolicyInternalServerErrorBody}
     * @memberof GetOryAccessControlPolicyInternalServerError
     */
    Payload?: GetOryAccessControlPolicyInternalServerErrorBody;
}
/**
 * GetOryAccessControlPolicyInternalServerErrorBody GetOryAccessControlPolicyInternalServerErrorBody get ory access control policy internal server error body
 * @export
 * @interface GetOryAccessControlPolicyInternalServerErrorBody
 */
export interface GetOryAccessControlPolicyInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof GetOryAccessControlPolicyInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof GetOryAccessControlPolicyInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof GetOryAccessControlPolicyInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof GetOryAccessControlPolicyInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof GetOryAccessControlPolicyInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof GetOryAccessControlPolicyInternalServerErrorBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface GetOryAccessControlPolicyNotFound
 */
export interface GetOryAccessControlPolicyNotFound {
    /**
     * 
     * @type {GetOryAccessControlPolicyNotFoundBody}
     * @memberof GetOryAccessControlPolicyNotFound
     */
    Payload?: GetOryAccessControlPolicyNotFoundBody;
}
/**
 * GetOryAccessControlPolicyNotFoundBody GetOryAccessControlPolicyNotFoundBody get ory access control policy not found body
 * @export
 * @interface GetOryAccessControlPolicyNotFoundBody
 */
export interface GetOryAccessControlPolicyNotFoundBody {
    /**
     * code
     * @type {number}
     * @memberof GetOryAccessControlPolicyNotFoundBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof GetOryAccessControlPolicyNotFoundBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof GetOryAccessControlPolicyNotFoundBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof GetOryAccessControlPolicyNotFoundBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof GetOryAccessControlPolicyNotFoundBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof GetOryAccessControlPolicyNotFoundBody
     */
    status?: string;
}
/**
 * oryAccessControlPolicy
 * @export
 * @interface GetOryAccessControlPolicyOK
 */
export interface GetOryAccessControlPolicyOK {
    /**
     * 
     * @type {OryAccessControlPolicy}
     * @memberof GetOryAccessControlPolicyOK
     */
    Payload?: OryAccessControlPolicy;
}
/**
 * GetOryAccessControlPolicyRole get ory access control policy role
 * @export
 * @interface GetOryAccessControlPolicyRole
 */
export interface GetOryAccessControlPolicyRole {
    /**
     * The ORY Access Control Policy flavor. Can be \"regex\", \"glob\", and \"exact\".  in: path
     * @type {string}
     * @memberof GetOryAccessControlPolicyRole
     */
    flavor: string;
    /**
     * The ID of the ORY Access Control Policy Role.  in: path
     * @type {string}
     * @memberof GetOryAccessControlPolicyRole
     */
    id: string;
}
/**
 * The standard error format
 * @export
 * @interface GetOryAccessControlPolicyRoleInternalServerError
 */
export interface GetOryAccessControlPolicyRoleInternalServerError {
    /**
     * 
     * @type {GetOryAccessControlPolicyRoleInternalServerErrorBody}
     * @memberof GetOryAccessControlPolicyRoleInternalServerError
     */
    Payload?: GetOryAccessControlPolicyRoleInternalServerErrorBody;
}
/**
 * GetOryAccessControlPolicyRoleInternalServerErrorBody get ory access control policy role internal server error body
 * @export
 * @interface GetOryAccessControlPolicyRoleInternalServerErrorBody
 */
export interface GetOryAccessControlPolicyRoleInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof GetOryAccessControlPolicyRoleInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof GetOryAccessControlPolicyRoleInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof GetOryAccessControlPolicyRoleInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof GetOryAccessControlPolicyRoleInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof GetOryAccessControlPolicyRoleInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof GetOryAccessControlPolicyRoleInternalServerErrorBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface GetOryAccessControlPolicyRoleNotFound
 */
export interface GetOryAccessControlPolicyRoleNotFound {
    /**
     * 
     * @type {GetOryAccessControlPolicyRoleNotFoundBody}
     * @memberof GetOryAccessControlPolicyRoleNotFound
     */
    Payload?: GetOryAccessControlPolicyRoleNotFoundBody;
}
/**
 * GetOryAccessControlPolicyRoleNotFoundBody GetOryAccessControlPolicyRoleNotFoundBody GetOryAccessControlPolicyRoleNotFoundBody get ory access control policy role not found body
 * @export
 * @interface GetOryAccessControlPolicyRoleNotFoundBody
 */
export interface GetOryAccessControlPolicyRoleNotFoundBody {
    /**
     * code
     * @type {number}
     * @memberof GetOryAccessControlPolicyRoleNotFoundBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof GetOryAccessControlPolicyRoleNotFoundBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof GetOryAccessControlPolicyRoleNotFoundBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof GetOryAccessControlPolicyRoleNotFoundBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof GetOryAccessControlPolicyRoleNotFoundBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof GetOryAccessControlPolicyRoleNotFoundBody
     */
    status?: string;
}
/**
 * oryAccessControlPolicyRole
 * @export
 * @interface GetOryAccessControlPolicyRoleOK
 */
export interface GetOryAccessControlPolicyRoleOK {
    /**
     * 
     * @type {OryAccessControlPolicyRole}
     * @memberof GetOryAccessControlPolicyRoleOK
     */
    Payload?: OryAccessControlPolicyRole;
}
/**
 * 
 * @export
 * @interface HealthNotReadyStatus
 */
export interface HealthNotReadyStatus {
    /**
     * Errors contains a list of errors that caused the not ready status.
     * @type {{ [key: string]: string; }}
     * @memberof HealthNotReadyStatus
     */
    errors?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface HealthStatus
 */
export interface HealthStatus {
    /**
     * Status always contains \"ok\".
     * @type {string}
     * @memberof HealthStatus
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse500
 */
export interface InlineResponse500 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse500
     */
    code?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof InlineResponse500
     */
    details?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse500
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse500
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse500
     */
    request?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse500
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface Input
 */
export interface Input {
    /**
     * Action is the action that is requested on the resource.
     * @type {string}
     * @memberof Input
     */
    action?: string;
    /**
     * Context is the request\'s environmental context.
     * @type {object}
     * @memberof Input
     */
    context?: object;
    /**
     * Resource is the resource that access is requested to.
     * @type {string}
     * @memberof Input
     */
    resource?: string;
    /**
     * Subject is the subject that is requesting access.
     * @type {string}
     * @memberof Input
     */
    subject?: string;
}
/**
 * The standard error format
 * @export
 * @interface IsInstanceAliveInternalServerError
 */
export interface IsInstanceAliveInternalServerError {
    /**
     * 
     * @type {IsInstanceAliveInternalServerErrorBody}
     * @memberof IsInstanceAliveInternalServerError
     */
    Payload?: IsInstanceAliveInternalServerErrorBody;
}
/**
 * IsInstanceAliveInternalServerErrorBody is instance alive internal server error body
 * @export
 * @interface IsInstanceAliveInternalServerErrorBody
 */
export interface IsInstanceAliveInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof IsInstanceAliveInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof IsInstanceAliveInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof IsInstanceAliveInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof IsInstanceAliveInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof IsInstanceAliveInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof IsInstanceAliveInternalServerErrorBody
     */
    status?: string;
}
/**
 * healthStatus
 * @export
 * @interface IsInstanceAliveOK
 */
export interface IsInstanceAliveOK {
    /**
     * 
     * @type {SwaggerHealthStatus}
     * @memberof IsInstanceAliveOK
     */
    Payload?: SwaggerHealthStatus;
}
/**
 * ListOryAccessControlPolicies list ory access control policies
 * @export
 * @interface ListOryAccessControlPolicies
 */
export interface ListOryAccessControlPolicies {
    /**
     * The ORY Access Control Policy flavor. Can be \"regex\", \"glob\", and \"exact\"  in: path
     * @type {string}
     * @memberof ListOryAccessControlPolicies
     */
    flavor: string;
    /**
     * The maximum amount of policies returned.  in: query
     * @type {number}
     * @memberof ListOryAccessControlPolicies
     */
    limit?: number;
    /**
     * The offset from where to start looking.  in: query
     * @type {number}
     * @memberof ListOryAccessControlPolicies
     */
    offset?: number;
}
/**
 * The standard error format
 * @export
 * @interface ListOryAccessControlPoliciesInternalServerError
 */
export interface ListOryAccessControlPoliciesInternalServerError {
    /**
     * 
     * @type {ListOryAccessControlPoliciesInternalServerErrorBody}
     * @memberof ListOryAccessControlPoliciesInternalServerError
     */
    Payload?: ListOryAccessControlPoliciesInternalServerErrorBody;
}
/**
 * ListOryAccessControlPoliciesInternalServerErrorBody ListOryAccessControlPoliciesInternalServerErrorBody ListOryAccessControlPoliciesInternalServerErrorBody ListOryAccessControlPoliciesInternalServerErrorBody list ory access control policies internal server error body
 * @export
 * @interface ListOryAccessControlPoliciesInternalServerErrorBody
 */
export interface ListOryAccessControlPoliciesInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof ListOryAccessControlPoliciesInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof ListOryAccessControlPoliciesInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof ListOryAccessControlPoliciesInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof ListOryAccessControlPoliciesInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof ListOryAccessControlPoliciesInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof ListOryAccessControlPoliciesInternalServerErrorBody
     */
    status?: string;
}
/**
 * Policies is an array of policies.
 * @export
 * @interface ListOryAccessControlPoliciesOK
 */
export interface ListOryAccessControlPoliciesOK {
    /**
     * payload
     * @type {Array<OryAccessControlPolicy>}
     * @memberof ListOryAccessControlPoliciesOK
     */
    Payload?: Array<OryAccessControlPolicy>;
}
/**
 * ListOryAccessControlPolicyRoles list ory access control policy roles
 * @export
 * @interface ListOryAccessControlPolicyRoles
 */
export interface ListOryAccessControlPolicyRoles {
    /**
     * The ORY Access Control Policy flavor. Can be \"regex\", \"glob\", and \"exact\"  in: path
     * @type {string}
     * @memberof ListOryAccessControlPolicyRoles
     */
    flavor: string;
    /**
     * The maximum amount of policies returned.  in: query
     * @type {number}
     * @memberof ListOryAccessControlPolicyRoles
     */
    limit?: number;
    /**
     * The offset from where to start looking.  in: query
     * @type {number}
     * @memberof ListOryAccessControlPolicyRoles
     */
    offset?: number;
}
/**
 * The standard error format
 * @export
 * @interface ListOryAccessControlPolicyRolesInternalServerError
 */
export interface ListOryAccessControlPolicyRolesInternalServerError {
    /**
     * 
     * @type {ListOryAccessControlPolicyRolesInternalServerErrorBody}
     * @memberof ListOryAccessControlPolicyRolesInternalServerError
     */
    Payload?: ListOryAccessControlPolicyRolesInternalServerErrorBody;
}
/**
 * ListOryAccessControlPolicyRolesInternalServerErrorBody ListOryAccessControlPolicyRolesInternalServerErrorBody list ory access control policy roles internal server error body
 * @export
 * @interface ListOryAccessControlPolicyRolesInternalServerErrorBody
 */
export interface ListOryAccessControlPolicyRolesInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof ListOryAccessControlPolicyRolesInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof ListOryAccessControlPolicyRolesInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof ListOryAccessControlPolicyRolesInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof ListOryAccessControlPolicyRolesInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof ListOryAccessControlPolicyRolesInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof ListOryAccessControlPolicyRolesInternalServerErrorBody
     */
    status?: string;
}
/**
 * Roles is an array of roles.
 * @export
 * @interface ListOryAccessControlPolicyRolesOK
 */
export interface ListOryAccessControlPolicyRolesOK {
    /**
     * payload
     * @type {Array<OryAccessControlPolicyRole>}
     * @memberof ListOryAccessControlPolicyRolesOK
     */
    Payload?: Array<OryAccessControlPolicyRole>;
}
/**
 * 
 * @export
 * @interface OryAccessControlPolicies
 */
export interface OryAccessControlPolicies {
    /**
     * The request body.  in: body type: array
     * @type {Array<OryAccessControlPolicy>}
     * @memberof OryAccessControlPolicies
     */
    Body?: Array<OryAccessControlPolicy>;
}
/**
 * 
 * @export
 * @interface OryAccessControlPolicy
 */
export interface OryAccessControlPolicy {
    /**
     * Actions is an array representing all the actions this ORY Access Policy applies to.
     * @type {Array<string>}
     * @memberof OryAccessControlPolicy
     */
    actions?: Array<string>;
    /**
     * Conditions represents a keyed object of conditions under which this ORY Access Policy is active.
     * @type {object}
     * @memberof OryAccessControlPolicy
     */
    conditions?: object;
    /**
     * Description is an optional, human-readable description.
     * @type {string}
     * @memberof OryAccessControlPolicy
     */
    description?: string;
    /**
     * Effect is the effect of this ORY Access Policy. It can be \"allow\" or \"deny\".
     * @type {string}
     * @memberof OryAccessControlPolicy
     */
    effect?: string;
    /**
     * ID is the unique identifier of the ORY Access Policy. It is used to query, update, and remove the ORY Access Policy.
     * @type {string}
     * @memberof OryAccessControlPolicy
     */
    id?: string;
    /**
     * Resources is an array representing all the resources this ORY Access Policy applies to.
     * @type {Array<string>}
     * @memberof OryAccessControlPolicy
     */
    resources?: Array<string>;
    /**
     * Subjects is an array representing all the subjects this ORY Access Policy applies to.
     * @type {Array<string>}
     * @memberof OryAccessControlPolicy
     */
    subjects?: Array<string>;
}
/**
 * 
 * @export
 * @interface OryAccessControlPolicyAllowedInput
 */
export interface OryAccessControlPolicyAllowedInput {
    /**
     * Action is the action that is requested on the resource.
     * @type {string}
     * @memberof OryAccessControlPolicyAllowedInput
     */
    action?: string;
    /**
     * Context is the request\'s environmental context.
     * @type {object}
     * @memberof OryAccessControlPolicyAllowedInput
     */
    context?: object;
    /**
     * Resource is the resource that access is requested to.
     * @type {string}
     * @memberof OryAccessControlPolicyAllowedInput
     */
    resource?: string;
    /**
     * Subject is the subject that is requesting access.
     * @type {string}
     * @memberof OryAccessControlPolicyAllowedInput
     */
    subject?: string;
}
/**
 * oryAccessControlPolicyRole represents a group of users that share the same role. A role could be an administrator, a moderator, a regular user or some other sort of role.
 * @export
 * @interface OryAccessControlPolicyRole
 */
export interface OryAccessControlPolicyRole {
    /**
     * ID is the role\'s unique id.
     * @type {string}
     * @memberof OryAccessControlPolicyRole
     */
    id?: string;
    /**
     * Members is who belongs to the role.
     * @type {Array<string>}
     * @memberof OryAccessControlPolicyRole
     */
    members?: Array<string>;
}
/**
 * 
 * @export
 * @interface OryAccessControlPolicyRoles
 */
export interface OryAccessControlPolicyRoles {
    /**
     * The request body.  in: body type: array
     * @type {Array<OryAccessControlPolicyRole>}
     * @memberof OryAccessControlPolicyRoles
     */
    Body?: Array<OryAccessControlPolicyRole>;
}
/**
 * 
 * @export
 * @interface Policy
 */
export interface Policy {
    /**
     * Actions is an array representing all the actions this ORY Access Policy applies to.
     * @type {Array<string>}
     * @memberof Policy
     */
    actions?: Array<string>;
    /**
     * Conditions represents a keyed object of conditions under which this ORY Access Policy is active.
     * @type {object}
     * @memberof Policy
     */
    conditions?: object;
    /**
     * Description is an optional, human-readable description.
     * @type {string}
     * @memberof Policy
     */
    description?: string;
    /**
     * Effect is the effect of this ORY Access Policy. It can be \"allow\" or \"deny\".
     * @type {string}
     * @memberof Policy
     */
    effect?: string;
    /**
     * ID is the unique identifier of the ORY Access Policy. It is used to query, update, and remove the ORY Access Policy.
     * @type {string}
     * @memberof Policy
     */
    id?: string;
    /**
     * Resources is an array representing all the resources this ORY Access Policy applies to.
     * @type {Array<string>}
     * @memberof Policy
     */
    resources?: Array<string>;
    /**
     * Subjects is an array representing all the subjects this ORY Access Policy applies to.
     * @type {Array<string>}
     * @memberof Policy
     */
    subjects?: Array<string>;
}
/**
 * RemoveOryAccessControlPolicyRoleMembers remove ory access control policy role members
 * @export
 * @interface RemoveOryAccessControlPolicyRoleMembers
 */
export interface RemoveOryAccessControlPolicyRoleMembers {
    /**
     * The ORY Access Control Policy flavor. Can be \"regex\", \"glob\", and \"exact\".  in: path
     * @type {string}
     * @memberof RemoveOryAccessControlPolicyRoleMembers
     */
    flavor: string;
    /**
     * The ID of the ORY Access Control Policy Role.  in: path
     * @type {string}
     * @memberof RemoveOryAccessControlPolicyRoleMembers
     */
    id: string;
    /**
     * The member to be removed.  in: path
     * @type {string}
     * @memberof RemoveOryAccessControlPolicyRoleMembers
     */
    member: string;
}
/**
 * The standard error format
 * @export
 * @interface RemoveOryAccessControlPolicyRoleMembersInternalServerError
 */
export interface RemoveOryAccessControlPolicyRoleMembersInternalServerError {
    /**
     * 
     * @type {RemoveOryAccessControlPolicyRoleMembersInternalServerErrorBody}
     * @memberof RemoveOryAccessControlPolicyRoleMembersInternalServerError
     */
    Payload?: RemoveOryAccessControlPolicyRoleMembersInternalServerErrorBody;
}
/**
 * RemoveOryAccessControlPolicyRoleMembersInternalServerErrorBody remove ory access control policy role members internal server error body
 * @export
 * @interface RemoveOryAccessControlPolicyRoleMembersInternalServerErrorBody
 */
export interface RemoveOryAccessControlPolicyRoleMembersInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof RemoveOryAccessControlPolicyRoleMembersInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof RemoveOryAccessControlPolicyRoleMembersInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof RemoveOryAccessControlPolicyRoleMembersInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof RemoveOryAccessControlPolicyRoleMembersInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof RemoveOryAccessControlPolicyRoleMembersInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof RemoveOryAccessControlPolicyRoleMembersInternalServerErrorBody
     */
    status?: string;
}
/**
 * Role Role Role Role Role Role Role Role Role represents a group of users that share the same role. A role could be an administrator, a moderator, a regular user or some other sort of role.
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * ID is the role\'s unique id.
     * @type {string}
     * @memberof Role
     */
    id?: string;
    /**
     * Members is who belongs to the role.
     * @type {Array<string>}
     * @memberof Role
     */
    members?: Array<string>;
}
/**
 * SwaggerHealthStatus swagger health status
 * @export
 * @interface SwaggerHealthStatus
 */
export interface SwaggerHealthStatus {
    /**
     * Status always contains \"ok\".
     * @type {string}
     * @memberof SwaggerHealthStatus
     */
    status?: string;
}
/**
 * SwaggerNotReadyStatus swagger not ready status
 * @export
 * @interface SwaggerNotReadyStatus
 */
export interface SwaggerNotReadyStatus {
    /**
     * Errors contains a list of errors that caused the not ready status.
     * @type {{ [key: string]: string; }}
     * @memberof SwaggerNotReadyStatus
     */
    errors?: { [key: string]: string; };
}
/**
 * SwaggerVersion swagger version
 * @export
 * @interface SwaggerVersion
 */
export interface SwaggerVersion {
    /**
     * Version is the service\'s version.
     * @type {string}
     * @memberof SwaggerVersion
     */
    version?: string;
}
/**
 * UpsertOryAccessControlPolicy upsert ory access control policy
 * @export
 * @interface UpsertOryAccessControlPolicy
 */
export interface UpsertOryAccessControlPolicy {
    /**
     * 
     * @type {OryAccessControlPolicy}
     * @memberof UpsertOryAccessControlPolicy
     */
    Body?: OryAccessControlPolicy;
    /**
     * The ORY Access Control Policy flavor. Can be \"regex\", \"glob\", and \"exact\".  in: path
     * @type {string}
     * @memberof UpsertOryAccessControlPolicy
     */
    flavor: string;
}
/**
 * The standard error format
 * @export
 * @interface UpsertOryAccessControlPolicyInternalServerError
 */
export interface UpsertOryAccessControlPolicyInternalServerError {
    /**
     * 
     * @type {UpsertOryAccessControlPolicyInternalServerErrorBody}
     * @memberof UpsertOryAccessControlPolicyInternalServerError
     */
    Payload?: UpsertOryAccessControlPolicyInternalServerErrorBody;
}
/**
 * UpsertOryAccessControlPolicyInternalServerErrorBody UpsertOryAccessControlPolicyInternalServerErrorBody UpsertOryAccessControlPolicyInternalServerErrorBody upsert ory access control policy internal server error body
 * @export
 * @interface UpsertOryAccessControlPolicyInternalServerErrorBody
 */
export interface UpsertOryAccessControlPolicyInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof UpsertOryAccessControlPolicyInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof UpsertOryAccessControlPolicyInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof UpsertOryAccessControlPolicyInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof UpsertOryAccessControlPolicyInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof UpsertOryAccessControlPolicyInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof UpsertOryAccessControlPolicyInternalServerErrorBody
     */
    status?: string;
}
/**
 * oryAccessControlPolicy
 * @export
 * @interface UpsertOryAccessControlPolicyOK
 */
export interface UpsertOryAccessControlPolicyOK {
    /**
     * 
     * @type {OryAccessControlPolicy}
     * @memberof UpsertOryAccessControlPolicyOK
     */
    Payload?: OryAccessControlPolicy;
}
/**
 * UpsertOryAccessControlPolicyRole upsert ory access control policy role
 * @export
 * @interface UpsertOryAccessControlPolicyRole
 */
export interface UpsertOryAccessControlPolicyRole {
    /**
     * 
     * @type {OryAccessControlPolicyRole}
     * @memberof UpsertOryAccessControlPolicyRole
     */
    Body?: OryAccessControlPolicyRole;
    /**
     * The ORY Access Control Policy flavor. Can be \"regex\", \"glob\", and \"exact\".  in: path
     * @type {string}
     * @memberof UpsertOryAccessControlPolicyRole
     */
    flavor: string;
}
/**
 * The standard error format
 * @export
 * @interface UpsertOryAccessControlPolicyRoleInternalServerError
 */
export interface UpsertOryAccessControlPolicyRoleInternalServerError {
    /**
     * 
     * @type {UpsertOryAccessControlPolicyRoleInternalServerErrorBody}
     * @memberof UpsertOryAccessControlPolicyRoleInternalServerError
     */
    Payload?: UpsertOryAccessControlPolicyRoleInternalServerErrorBody;
}
/**
 * UpsertOryAccessControlPolicyRoleInternalServerErrorBody upsert ory access control policy role internal server error body
 * @export
 * @interface UpsertOryAccessControlPolicyRoleInternalServerErrorBody
 */
export interface UpsertOryAccessControlPolicyRoleInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof UpsertOryAccessControlPolicyRoleInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof UpsertOryAccessControlPolicyRoleInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof UpsertOryAccessControlPolicyRoleInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof UpsertOryAccessControlPolicyRoleInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof UpsertOryAccessControlPolicyRoleInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof UpsertOryAccessControlPolicyRoleInternalServerErrorBody
     */
    status?: string;
}
/**
 * oryAccessControlPolicyRole
 * @export
 * @interface UpsertOryAccessControlPolicyRoleOK
 */
export interface UpsertOryAccessControlPolicyRoleOK {
    /**
     * 
     * @type {OryAccessControlPolicyRole}
     * @memberof UpsertOryAccessControlPolicyRoleOK
     */
    Payload?: OryAccessControlPolicyRole;
}
/**
 * 
 * @export
 * @interface Version
 */
export interface Version {
    /**
     * Version is the service\'s version.
     * @type {string}
     * @memberof Version
     */
    version?: string;
}

/**
 * EnginesApi - axios parameter creator
 * @export
 */
export const EnginesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Add a member to an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {AddOryAccessControlPolicyRoleMembersBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOryAccessControlPolicyRoleMembers: async (flavor: string, id: string, body?: AddOryAccessControlPolicyRoleMembersBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling addOryAccessControlPolicyRoleMembers.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addOryAccessControlPolicyRoleMembers.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/roles/{id}/members`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an ORY Access Control Policy
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOryAccessControlPolicy: async (flavor: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling deleteOryAccessControlPolicy.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteOryAccessControlPolicy.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/policies/{id}`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Delete an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOryAccessControlPolicyRole: async (flavor: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling deleteOryAccessControlPolicyRole.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteOryAccessControlPolicyRole.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/roles/{id}`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to check if a request is allowed or not. If the request is allowed, a 200 response with `{\"allowed\":\"true\"}` will be sent. If the request is denied, a 403 response with `{\"allowed\":\"false\"}` will be sent instead.
         * @summary Check if a request is allowed
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {OryAccessControlPolicyAllowedInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doOryAccessControlPoliciesAllow: async (flavor: string, body?: OryAccessControlPolicyAllowedInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling doOryAccessControlPoliciesAllow.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/allowed`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an ORY Access Control Policy
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOryAccessControlPolicy: async (flavor: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling getOryAccessControlPolicy.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getOryAccessControlPolicy.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/policies/{id}`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Get an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOryAccessControlPolicyRole: async (flavor: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling getOryAccessControlPolicyRole.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getOryAccessControlPolicyRole.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/roles/{id}`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List ORY Access Control Policies
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;
         * @param {number} [limit] The maximum amount of policies returned.
         * @param {number} [offset] The offset from where to start looking.
         * @param {string} [subject] The subject for whom the policies are to be listed.
         * @param {string} [resource] The resource for which the policies are to be listed.
         * @param {string} [action] The action for which policies are to be listed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOryAccessControlPolicies: async (flavor: string, limit?: number, offset?: number, subject?: string, resource?: string, action?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling listOryAccessControlPolicies.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/policies`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (subject !== undefined) {
                localVarQueryParameter['subject'] = subject;
            }

            if (resource !== undefined) {
                localVarQueryParameter['resource'] = resource;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary List ORY Access Control Policy Roles
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;
         * @param {number} [limit] The maximum amount of policies returned.
         * @param {number} [offset] The offset from where to start looking.
         * @param {string} [member] The member for which the roles are to be listed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOryAccessControlPolicyRoles: async (flavor: string, limit?: number, offset?: number, member?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling listOryAccessControlPolicyRoles.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/roles`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (member !== undefined) {
                localVarQueryParameter['member'] = member;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Remove a member from an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {string} member The member to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOryAccessControlPolicyRoleMembers: async (flavor: string, id: string, member: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling removeOryAccessControlPolicyRoleMembers.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling removeOryAccessControlPolicyRoleMembers.');
            }
            // verify required parameter 'member' is not null or undefined
            if (member === null || member === undefined) {
                throw new RequiredError('member','Required parameter member was null or undefined when calling removeOryAccessControlPolicyRoleMembers.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/roles/{id}/members/{member}`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"member"}}`, encodeURIComponent(String(member)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert an ORY Access Control Policy
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {OryAccessControlPolicy} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertOryAccessControlPolicy: async (flavor: string, body?: OryAccessControlPolicy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling upsertOryAccessControlPolicy.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/policies`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Upsert an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {OryAccessControlPolicyRole} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertOryAccessControlPolicyRole: async (flavor: string, body?: OryAccessControlPolicyRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling upsertOryAccessControlPolicyRole.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/roles`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnginesApi - functional programming interface
 * @export
 */
export const EnginesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Add a member to an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {AddOryAccessControlPolicyRoleMembersBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOryAccessControlPolicyRoleMembers(flavor: string, id: string, body?: AddOryAccessControlPolicyRoleMembersBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OryAccessControlPolicyRole>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).addOryAccessControlPolicyRoleMembers(flavor, id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete an ORY Access Control Policy
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOryAccessControlPolicy(flavor: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).deleteOryAccessControlPolicy(flavor, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Delete an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOryAccessControlPolicyRole(flavor: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).deleteOryAccessControlPolicyRole(flavor, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this endpoint to check if a request is allowed or not. If the request is allowed, a 200 response with `{\"allowed\":\"true\"}` will be sent. If the request is denied, a 403 response with `{\"allowed\":\"false\"}` will be sent instead.
         * @summary Check if a request is allowed
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {OryAccessControlPolicyAllowedInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doOryAccessControlPoliciesAllow(flavor: string, body?: OryAccessControlPolicyAllowedInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorizationResult>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).doOryAccessControlPoliciesAllow(flavor, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get an ORY Access Control Policy
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOryAccessControlPolicy(flavor: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OryAccessControlPolicy>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).getOryAccessControlPolicy(flavor, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Get an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOryAccessControlPolicyRole(flavor: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OryAccessControlPolicyRole>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).getOryAccessControlPolicyRole(flavor, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List ORY Access Control Policies
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;
         * @param {number} [limit] The maximum amount of policies returned.
         * @param {number} [offset] The offset from where to start looking.
         * @param {string} [subject] The subject for whom the policies are to be listed.
         * @param {string} [resource] The resource for which the policies are to be listed.
         * @param {string} [action] The action for which policies are to be listed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOryAccessControlPolicies(flavor: string, limit?: number, offset?: number, subject?: string, resource?: string, action?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OryAccessControlPolicy>>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).listOryAccessControlPolicies(flavor, limit, offset, subject, resource, action, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary List ORY Access Control Policy Roles
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;
         * @param {number} [limit] The maximum amount of policies returned.
         * @param {number} [offset] The offset from where to start looking.
         * @param {string} [member] The member for which the roles are to be listed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOryAccessControlPolicyRoles(flavor: string, limit?: number, offset?: number, member?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OryAccessControlPolicyRole>>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).listOryAccessControlPolicyRoles(flavor, limit, offset, member, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Remove a member from an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {string} member The member to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOryAccessControlPolicyRoleMembers(flavor: string, id: string, member: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).removeOryAccessControlPolicyRoleMembers(flavor, id, member, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upsert an ORY Access Control Policy
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {OryAccessControlPolicy} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertOryAccessControlPolicy(flavor: string, body?: OryAccessControlPolicy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OryAccessControlPolicy>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).upsertOryAccessControlPolicy(flavor, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Upsert an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {OryAccessControlPolicyRole} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertOryAccessControlPolicyRole(flavor: string, body?: OryAccessControlPolicyRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OryAccessControlPolicyRole>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).upsertOryAccessControlPolicyRole(flavor, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EnginesApi - factory interface
 * @export
 */
export const EnginesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Add a member to an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {AddOryAccessControlPolicyRoleMembersBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOryAccessControlPolicyRoleMembers(flavor: string, id: string, body?: AddOryAccessControlPolicyRoleMembersBody, options?: any): AxiosPromise<OryAccessControlPolicyRole> {
            return EnginesApiFp(configuration).addOryAccessControlPolicyRoleMembers(flavor, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an ORY Access Control Policy
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOryAccessControlPolicy(flavor: string, id: string, options?: any): AxiosPromise<void> {
            return EnginesApiFp(configuration).deleteOryAccessControlPolicy(flavor, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Delete an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOryAccessControlPolicyRole(flavor: string, id: string, options?: any): AxiosPromise<void> {
            return EnginesApiFp(configuration).deleteOryAccessControlPolicyRole(flavor, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to check if a request is allowed or not. If the request is allowed, a 200 response with `{\"allowed\":\"true\"}` will be sent. If the request is denied, a 403 response with `{\"allowed\":\"false\"}` will be sent instead.
         * @summary Check if a request is allowed
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {OryAccessControlPolicyAllowedInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doOryAccessControlPoliciesAllow(flavor: string, body?: OryAccessControlPolicyAllowedInput, options?: any): AxiosPromise<AuthorizationResult> {
            return EnginesApiFp(configuration).doOryAccessControlPoliciesAllow(flavor, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an ORY Access Control Policy
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOryAccessControlPolicy(flavor: string, id: string, options?: any): AxiosPromise<OryAccessControlPolicy> {
            return EnginesApiFp(configuration).getOryAccessControlPolicy(flavor, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Get an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOryAccessControlPolicyRole(flavor: string, id: string, options?: any): AxiosPromise<OryAccessControlPolicyRole> {
            return EnginesApiFp(configuration).getOryAccessControlPolicyRole(flavor, id, options).then((request) => request(axios, basePath));
        },
        /**
         * List ORY Access Control Policies
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;
         * @param {number} [limit] The maximum amount of policies returned.
         * @param {number} [offset] The offset from where to start looking.
         * @param {string} [subject] The subject for whom the policies are to be listed.
         * @param {string} [resource] The resource for which the policies are to be listed.
         * @param {string} [action] The action for which policies are to be listed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOryAccessControlPolicies(flavor: string, limit?: number, offset?: number, subject?: string, resource?: string, action?: string, options?: any): AxiosPromise<Array<OryAccessControlPolicy>> {
            return EnginesApiFp(configuration).listOryAccessControlPolicies(flavor, limit, offset, subject, resource, action, options).then((request) => request(axios, basePath));
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary List ORY Access Control Policy Roles
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;
         * @param {number} [limit] The maximum amount of policies returned.
         * @param {number} [offset] The offset from where to start looking.
         * @param {string} [member] The member for which the roles are to be listed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOryAccessControlPolicyRoles(flavor: string, limit?: number, offset?: number, member?: string, options?: any): AxiosPromise<Array<OryAccessControlPolicyRole>> {
            return EnginesApiFp(configuration).listOryAccessControlPolicyRoles(flavor, limit, offset, member, options).then((request) => request(axios, basePath));
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Remove a member from an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {string} member The member to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOryAccessControlPolicyRoleMembers(flavor: string, id: string, member: string, options?: any): AxiosPromise<void> {
            return EnginesApiFp(configuration).removeOryAccessControlPolicyRoleMembers(flavor, id, member, options).then((request) => request(axios, basePath));
        },
        /**
         * Upsert an ORY Access Control Policy
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {OryAccessControlPolicy} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertOryAccessControlPolicy(flavor: string, body?: OryAccessControlPolicy, options?: any): AxiosPromise<OryAccessControlPolicy> {
            return EnginesApiFp(configuration).upsertOryAccessControlPolicy(flavor, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Upsert an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {OryAccessControlPolicyRole} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertOryAccessControlPolicyRole(flavor: string, body?: OryAccessControlPolicyRole, options?: any): AxiosPromise<OryAccessControlPolicyRole> {
            return EnginesApiFp(configuration).upsertOryAccessControlPolicyRole(flavor, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnginesApi - object-oriented interface
 * @export
 * @class EnginesApi
 * @extends {BaseAPI}
 */
export class EnginesApi extends BaseAPI {
    /**
     * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
     * @summary Add a member to an ORY Access Control Policy Role
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
     * @param {string} id The ID of the ORY Access Control Policy Role.
     * @param {AddOryAccessControlPolicyRoleMembersBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public addOryAccessControlPolicyRoleMembers(flavor: string, id: string, body?: AddOryAccessControlPolicyRoleMembersBody, options?: any) {
        return EnginesApiFp(this.configuration).addOryAccessControlPolicyRoleMembers(flavor, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an ORY Access Control Policy
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
     * @param {string} id The ID of the ORY Access Control Policy Role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public deleteOryAccessControlPolicy(flavor: string, id: string, options?: any) {
        return EnginesApiFp(this.configuration).deleteOryAccessControlPolicy(flavor, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
     * @summary Delete an ORY Access Control Policy Role
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
     * @param {string} id The ID of the ORY Access Control Policy Role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public deleteOryAccessControlPolicyRole(flavor: string, id: string, options?: any) {
        return EnginesApiFp(this.configuration).deleteOryAccessControlPolicyRole(flavor, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to check if a request is allowed or not. If the request is allowed, a 200 response with `{\"allowed\":\"true\"}` will be sent. If the request is denied, a 403 response with `{\"allowed\":\"false\"}` will be sent instead.
     * @summary Check if a request is allowed
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
     * @param {OryAccessControlPolicyAllowedInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public doOryAccessControlPoliciesAllow(flavor: string, body?: OryAccessControlPolicyAllowedInput, options?: any) {
        return EnginesApiFp(this.configuration).doOryAccessControlPoliciesAllow(flavor, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an ORY Access Control Policy
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
     * @param {string} id The ID of the ORY Access Control Policy Role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public getOryAccessControlPolicy(flavor: string, id: string, options?: any) {
        return EnginesApiFp(this.configuration).getOryAccessControlPolicy(flavor, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
     * @summary Get an ORY Access Control Policy Role
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
     * @param {string} id The ID of the ORY Access Control Policy Role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public getOryAccessControlPolicyRole(flavor: string, id: string, options?: any) {
        return EnginesApiFp(this.configuration).getOryAccessControlPolicyRole(flavor, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List ORY Access Control Policies
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;
     * @param {number} [limit] The maximum amount of policies returned.
     * @param {number} [offset] The offset from where to start looking.
     * @param {string} [subject] The subject for whom the policies are to be listed.
     * @param {string} [resource] The resource for which the policies are to be listed.
     * @param {string} [action] The action for which policies are to be listed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public listOryAccessControlPolicies(flavor: string, limit?: number, offset?: number, subject?: string, resource?: string, action?: string, options?: any) {
        return EnginesApiFp(this.configuration).listOryAccessControlPolicies(flavor, limit, offset, subject, resource, action, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
     * @summary List ORY Access Control Policy Roles
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;
     * @param {number} [limit] The maximum amount of policies returned.
     * @param {number} [offset] The offset from where to start looking.
     * @param {string} [member] The member for which the roles are to be listed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public listOryAccessControlPolicyRoles(flavor: string, limit?: number, offset?: number, member?: string, options?: any) {
        return EnginesApiFp(this.configuration).listOryAccessControlPolicyRoles(flavor, limit, offset, member, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
     * @summary Remove a member from an ORY Access Control Policy Role
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
     * @param {string} id The ID of the ORY Access Control Policy Role.
     * @param {string} member The member to be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public removeOryAccessControlPolicyRoleMembers(flavor: string, id: string, member: string, options?: any) {
        return EnginesApiFp(this.configuration).removeOryAccessControlPolicyRoleMembers(flavor, id, member, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upsert an ORY Access Control Policy
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
     * @param {OryAccessControlPolicy} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public upsertOryAccessControlPolicy(flavor: string, body?: OryAccessControlPolicy, options?: any) {
        return EnginesApiFp(this.configuration).upsertOryAccessControlPolicy(flavor, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
     * @summary Upsert an ORY Access Control Policy Role
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
     * @param {OryAccessControlPolicyRole} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public upsertOryAccessControlPolicyRole(flavor: string, body?: OryAccessControlPolicyRole, options?: any) {
        return EnginesApiFp(this.configuration).upsertOryAccessControlPolicyRole(flavor, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check alive status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isInstanceAlive: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/alive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check readiness status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isInstanceReady: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/ready`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check alive status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isInstanceAlive(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await HealthApiAxiosParamCreator(configuration).isInstanceAlive(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check readiness status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isInstanceReady(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await HealthApiAxiosParamCreator(configuration).isInstanceReady(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check alive status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isInstanceAlive(options?: any): AxiosPromise<HealthStatus> {
            return HealthApiFp(configuration).isInstanceAlive(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check readiness status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isInstanceReady(options?: any): AxiosPromise<HealthStatus> {
            return HealthApiFp(configuration).isInstanceReady(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
     * @summary Check alive status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public isInstanceAlive(options?: any) {
        return HealthApiFp(this.configuration).isInstanceAlive(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
     * @summary Check readiness status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public isInstanceReady(options?: any) {
        return HealthApiFp(this.configuration).isInstanceReady(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VersionApi - axios parameter creator
 * @export
 */
export const VersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Get service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionApi - functional programming interface
 * @export
 */
export const VersionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Get service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Version>> {
            const localVarAxiosArgs = await VersionApiAxiosParamCreator(configuration).getVersion(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VersionApi - factory interface
 * @export
 */
export const VersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Get service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: any): AxiosPromise<Version> {
            return VersionApiFp(configuration).getVersion(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersionApi - object-oriented interface
 * @export
 * @class VersionApi
 * @extends {BaseAPI}
 */
export class VersionApi extends BaseAPI {
    /**
     * This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
     * @summary Get service version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public getVersion(options?: any) {
        return VersionApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
    }
}


