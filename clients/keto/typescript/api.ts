/* tslint:disable */
/* eslint-disable */
/**
 * ORY Keto
 * Ory Keto is a cloud native access control server providing best-practice patterns (RBAC, ABAC, ACL, AWS IAM Policies, Kubernetes Roles, ...) via REST APIs.
 *
 * The version of the OpenAPI document: v0.0.0-alpha.55
 * Contact: hi@ory.sh
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddOryAccessControlPolicyRoleMembersBody
 */
export interface AddOryAccessControlPolicyRoleMembersBody {
    /**
     * The members to be added.
     * @type {Array<string>}
     * @memberof AddOryAccessControlPolicyRoleMembersBody
     */
    members?: Array<string>;
}
/**
 * 
 * @export
 * @interface AuthorizationResult
 */
export interface AuthorizationResult {
    /**
     * Allowed is true if the request should be allowed and false otherwise.
     * @type {boolean}
     * @memberof AuthorizationResult
     */
    allowed: boolean;
}
/**
 * 
 * @export
 * @interface HealthNotReadyStatus
 */
export interface HealthNotReadyStatus {
    /**
     * Errors contains a list of errors that caused the not ready status.
     * @type {{ [key: string]: string; }}
     * @memberof HealthNotReadyStatus
     */
    errors?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface HealthStatus
 */
export interface HealthStatus {
    /**
     * Status always contains \"ok\".
     * @type {string}
     * @memberof HealthStatus
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse500
 */
export interface InlineResponse500 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse500
     */
    code?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof InlineResponse500
     */
    details?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse500
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse500
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse500
     */
    request?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse500
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface OryAccessControlPolicy
 */
export interface OryAccessControlPolicy {
    /**
     * Actions is an array representing all the actions this ORY Access Policy applies to.
     * @type {Array<string>}
     * @memberof OryAccessControlPolicy
     */
    actions?: Array<string>;
    /**
     * Conditions represents a keyed object of conditions under which this ORY Access Policy is active.
     * @type {object}
     * @memberof OryAccessControlPolicy
     */
    conditions?: object;
    /**
     * Description is an optional, human-readable description.
     * @type {string}
     * @memberof OryAccessControlPolicy
     */
    description?: string;
    /**
     * Effect is the effect of this ORY Access Policy. It can be \"allow\" or \"deny\".
     * @type {string}
     * @memberof OryAccessControlPolicy
     */
    effect?: string;
    /**
     * ID is the unique identifier of the ORY Access Policy. It is used to query, update, and remove the ORY Access Policy.
     * @type {string}
     * @memberof OryAccessControlPolicy
     */
    id?: string;
    /**
     * Resources is an array representing all the resources this ORY Access Policy applies to.
     * @type {Array<string>}
     * @memberof OryAccessControlPolicy
     */
    resources?: Array<string>;
    /**
     * Subjects is an array representing all the subjects this ORY Access Policy applies to.
     * @type {Array<string>}
     * @memberof OryAccessControlPolicy
     */
    subjects?: Array<string>;
}
/**
 * 
 * @export
 * @interface OryAccessControlPolicyAllowedInput
 */
export interface OryAccessControlPolicyAllowedInput {
    /**
     * Action is the action that is requested on the resource.
     * @type {string}
     * @memberof OryAccessControlPolicyAllowedInput
     */
    action?: string;
    /**
     * Context is the request\'s environmental context.
     * @type {object}
     * @memberof OryAccessControlPolicyAllowedInput
     */
    context?: object;
    /**
     * Resource is the resource that access is requested to.
     * @type {string}
     * @memberof OryAccessControlPolicyAllowedInput
     */
    resource?: string;
    /**
     * Subject is the subject that is requesting access.
     * @type {string}
     * @memberof OryAccessControlPolicyAllowedInput
     */
    subject?: string;
}
/**
 * oryAccessControlPolicyRole represents a group of users that share the same role. A role could be an administrator, a moderator, a regular user or some other sort of role.
 * @export
 * @interface OryAccessControlPolicyRole
 */
export interface OryAccessControlPolicyRole {
    /**
     * ID is the role\'s unique id.
     * @type {string}
     * @memberof OryAccessControlPolicyRole
     */
    id?: string;
    /**
     * Members is who belongs to the role.
     * @type {Array<string>}
     * @memberof OryAccessControlPolicyRole
     */
    members?: Array<string>;
}
/**
 * 
 * @export
 * @interface Version
 */
export interface Version {
    /**
     * Version is the service\'s version.
     * @type {string}
     * @memberof Version
     */
    version?: string;
}

/**
 * EnginesApi - axios parameter creator
 * @export
 */
export const EnginesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Add a member to an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {AddOryAccessControlPolicyRoleMembersBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOryAccessControlPolicyRoleMembers: async (flavor: string, id: string, body?: AddOryAccessControlPolicyRoleMembersBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling addOryAccessControlPolicyRoleMembers.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addOryAccessControlPolicyRoleMembers.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/roles/{id}/members`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an ORY Access Control Policy
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOryAccessControlPolicy: async (flavor: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling deleteOryAccessControlPolicy.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteOryAccessControlPolicy.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/policies/{id}`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Delete an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOryAccessControlPolicyRole: async (flavor: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling deleteOryAccessControlPolicyRole.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteOryAccessControlPolicyRole.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/roles/{id}`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to check if a request is allowed or not. If the request is allowed, a 200 response with `{\"allowed\":\"true\"}` will be sent. If the request is denied, a 403 response with `{\"allowed\":\"false\"}` will be sent instead.
         * @summary Check if a request is allowed
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {OryAccessControlPolicyAllowedInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doOryAccessControlPoliciesAllow: async (flavor: string, body?: OryAccessControlPolicyAllowedInput, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling doOryAccessControlPoliciesAllow.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/allowed`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an ORY Access Control Policy
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOryAccessControlPolicy: async (flavor: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling getOryAccessControlPolicy.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getOryAccessControlPolicy.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/policies/{id}`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Get an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOryAccessControlPolicyRole: async (flavor: string, id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling getOryAccessControlPolicyRole.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getOryAccessControlPolicyRole.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/roles/{id}`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List ORY Access Control Policies
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;
         * @param {number} [limit] The maximum amount of policies returned.
         * @param {number} [offset] The offset from where to start looking.
         * @param {string} [subject] The subject for whom the policies are to be listed.
         * @param {string} [resource] The resource for which the policies are to be listed.
         * @param {string} [action] The action for which policies are to be listed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOryAccessControlPolicies: async (flavor: string, limit?: number, offset?: number, subject?: string, resource?: string, action?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling listOryAccessControlPolicies.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/policies`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (subject !== undefined) {
                localVarQueryParameter['subject'] = subject;
            }

            if (resource !== undefined) {
                localVarQueryParameter['resource'] = resource;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary List ORY Access Control Policy Roles
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;
         * @param {number} [limit] The maximum amount of policies returned.
         * @param {number} [offset] The offset from where to start looking.
         * @param {string} [member] The member for which the roles are to be listed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOryAccessControlPolicyRoles: async (flavor: string, limit?: number, offset?: number, member?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling listOryAccessControlPolicyRoles.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/roles`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (member !== undefined) {
                localVarQueryParameter['member'] = member;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Remove a member from an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {string} member The member to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOryAccessControlPolicyRoleMembers: async (flavor: string, id: string, member: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling removeOryAccessControlPolicyRoleMembers.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling removeOryAccessControlPolicyRoleMembers.');
            }
            // verify required parameter 'member' is not null or undefined
            if (member === null || member === undefined) {
                throw new RequiredError('member','Required parameter member was null or undefined when calling removeOryAccessControlPolicyRoleMembers.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/roles/{id}/members/{member}`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"member"}}`, encodeURIComponent(String(member)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Upsert an ORY Access Control Policy
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {OryAccessControlPolicy} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertOryAccessControlPolicy: async (flavor: string, body?: OryAccessControlPolicy, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling upsertOryAccessControlPolicy.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/policies`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Upsert an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {OryAccessControlPolicyRole} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertOryAccessControlPolicyRole: async (flavor: string, body?: OryAccessControlPolicyRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavor' is not null or undefined
            if (flavor === null || flavor === undefined) {
                throw new RequiredError('flavor','Required parameter flavor was null or undefined when calling upsertOryAccessControlPolicyRole.');
            }
            const localVarPath = `/engines/acp/ory/{flavor}/roles`
                .replace(`{${"flavor"}}`, encodeURIComponent(String(flavor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof body !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(body !== undefined ? body : {})
                : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnginesApi - functional programming interface
 * @export
 */
export const EnginesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Add a member to an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {AddOryAccessControlPolicyRoleMembersBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOryAccessControlPolicyRoleMembers(flavor: string, id: string, body?: AddOryAccessControlPolicyRoleMembersBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OryAccessControlPolicyRole>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).addOryAccessControlPolicyRoleMembers(flavor, id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete an ORY Access Control Policy
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOryAccessControlPolicy(flavor: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).deleteOryAccessControlPolicy(flavor, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Delete an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOryAccessControlPolicyRole(flavor: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).deleteOryAccessControlPolicyRole(flavor, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Use this endpoint to check if a request is allowed or not. If the request is allowed, a 200 response with `{\"allowed\":\"true\"}` will be sent. If the request is denied, a 403 response with `{\"allowed\":\"false\"}` will be sent instead.
         * @summary Check if a request is allowed
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {OryAccessControlPolicyAllowedInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doOryAccessControlPoliciesAllow(flavor: string, body?: OryAccessControlPolicyAllowedInput, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorizationResult>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).doOryAccessControlPoliciesAllow(flavor, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get an ORY Access Control Policy
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOryAccessControlPolicy(flavor: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OryAccessControlPolicy>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).getOryAccessControlPolicy(flavor, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Get an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOryAccessControlPolicyRole(flavor: string, id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OryAccessControlPolicyRole>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).getOryAccessControlPolicyRole(flavor, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List ORY Access Control Policies
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;
         * @param {number} [limit] The maximum amount of policies returned.
         * @param {number} [offset] The offset from where to start looking.
         * @param {string} [subject] The subject for whom the policies are to be listed.
         * @param {string} [resource] The resource for which the policies are to be listed.
         * @param {string} [action] The action for which policies are to be listed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOryAccessControlPolicies(flavor: string, limit?: number, offset?: number, subject?: string, resource?: string, action?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OryAccessControlPolicy>>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).listOryAccessControlPolicies(flavor, limit, offset, subject, resource, action, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary List ORY Access Control Policy Roles
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;
         * @param {number} [limit] The maximum amount of policies returned.
         * @param {number} [offset] The offset from where to start looking.
         * @param {string} [member] The member for which the roles are to be listed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOryAccessControlPolicyRoles(flavor: string, limit?: number, offset?: number, member?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OryAccessControlPolicyRole>>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).listOryAccessControlPolicyRoles(flavor, limit, offset, member, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Remove a member from an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {string} member The member to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeOryAccessControlPolicyRoleMembers(flavor: string, id: string, member: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).removeOryAccessControlPolicyRoleMembers(flavor, id, member, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Upsert an ORY Access Control Policy
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {OryAccessControlPolicy} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertOryAccessControlPolicy(flavor: string, body?: OryAccessControlPolicy, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OryAccessControlPolicy>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).upsertOryAccessControlPolicy(flavor, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Upsert an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {OryAccessControlPolicyRole} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upsertOryAccessControlPolicyRole(flavor: string, body?: OryAccessControlPolicyRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OryAccessControlPolicyRole>> {
            const localVarAxiosArgs = await EnginesApiAxiosParamCreator(configuration).upsertOryAccessControlPolicyRole(flavor, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EnginesApi - factory interface
 * @export
 */
export const EnginesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Add a member to an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {AddOryAccessControlPolicyRoleMembersBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOryAccessControlPolicyRoleMembers(flavor: string, id: string, body?: AddOryAccessControlPolicyRoleMembersBody, options?: any): AxiosPromise<OryAccessControlPolicyRole> {
            return EnginesApiFp(configuration).addOryAccessControlPolicyRoleMembers(flavor, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an ORY Access Control Policy
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOryAccessControlPolicy(flavor: string, id: string, options?: any): AxiosPromise<void> {
            return EnginesApiFp(configuration).deleteOryAccessControlPolicy(flavor, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Delete an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOryAccessControlPolicyRole(flavor: string, id: string, options?: any): AxiosPromise<void> {
            return EnginesApiFp(configuration).deleteOryAccessControlPolicyRole(flavor, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to check if a request is allowed or not. If the request is allowed, a 200 response with `{\"allowed\":\"true\"}` will be sent. If the request is denied, a 403 response with `{\"allowed\":\"false\"}` will be sent instead.
         * @summary Check if a request is allowed
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {OryAccessControlPolicyAllowedInput} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doOryAccessControlPoliciesAllow(flavor: string, body?: OryAccessControlPolicyAllowedInput, options?: any): AxiosPromise<AuthorizationResult> {
            return EnginesApiFp(configuration).doOryAccessControlPoliciesAllow(flavor, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an ORY Access Control Policy
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOryAccessControlPolicy(flavor: string, id: string, options?: any): AxiosPromise<OryAccessControlPolicy> {
            return EnginesApiFp(configuration).getOryAccessControlPolicy(flavor, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Get an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOryAccessControlPolicyRole(flavor: string, id: string, options?: any): AxiosPromise<OryAccessControlPolicyRole> {
            return EnginesApiFp(configuration).getOryAccessControlPolicyRole(flavor, id, options).then((request) => request(axios, basePath));
        },
        /**
         * List ORY Access Control Policies
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;
         * @param {number} [limit] The maximum amount of policies returned.
         * @param {number} [offset] The offset from where to start looking.
         * @param {string} [subject] The subject for whom the policies are to be listed.
         * @param {string} [resource] The resource for which the policies are to be listed.
         * @param {string} [action] The action for which policies are to be listed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOryAccessControlPolicies(flavor: string, limit?: number, offset?: number, subject?: string, resource?: string, action?: string, options?: any): AxiosPromise<Array<OryAccessControlPolicy>> {
            return EnginesApiFp(configuration).listOryAccessControlPolicies(flavor, limit, offset, subject, resource, action, options).then((request) => request(axios, basePath));
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary List ORY Access Control Policy Roles
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;
         * @param {number} [limit] The maximum amount of policies returned.
         * @param {number} [offset] The offset from where to start looking.
         * @param {string} [member] The member for which the roles are to be listed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOryAccessControlPolicyRoles(flavor: string, limit?: number, offset?: number, member?: string, options?: any): AxiosPromise<Array<OryAccessControlPolicyRole>> {
            return EnginesApiFp(configuration).listOryAccessControlPolicyRoles(flavor, limit, offset, member, options).then((request) => request(axios, basePath));
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Remove a member from an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {string} id The ID of the ORY Access Control Policy Role.
         * @param {string} member The member to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeOryAccessControlPolicyRoleMembers(flavor: string, id: string, member: string, options?: any): AxiosPromise<void> {
            return EnginesApiFp(configuration).removeOryAccessControlPolicyRoleMembers(flavor, id, member, options).then((request) => request(axios, basePath));
        },
        /**
         * Upsert an ORY Access Control Policy
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {OryAccessControlPolicy} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertOryAccessControlPolicy(flavor: string, body?: OryAccessControlPolicy, options?: any): AxiosPromise<OryAccessControlPolicy> {
            return EnginesApiFp(configuration).upsertOryAccessControlPolicy(flavor, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
         * @summary Upsert an ORY Access Control Policy Role
         * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
         * @param {OryAccessControlPolicyRole} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upsertOryAccessControlPolicyRole(flavor: string, body?: OryAccessControlPolicyRole, options?: any): AxiosPromise<OryAccessControlPolicyRole> {
            return EnginesApiFp(configuration).upsertOryAccessControlPolicyRole(flavor, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnginesApi - object-oriented interface
 * @export
 * @class EnginesApi
 * @extends {BaseAPI}
 */
export class EnginesApi extends BaseAPI {
    /**
     * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
     * @summary Add a member to an ORY Access Control Policy Role
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
     * @param {string} id The ID of the ORY Access Control Policy Role.
     * @param {AddOryAccessControlPolicyRoleMembersBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public addOryAccessControlPolicyRoleMembers(flavor: string, id: string, body?: AddOryAccessControlPolicyRoleMembersBody, options?: any) {
        return EnginesApiFp(this.configuration).addOryAccessControlPolicyRoleMembers(flavor, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an ORY Access Control Policy
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
     * @param {string} id The ID of the ORY Access Control Policy Role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public deleteOryAccessControlPolicy(flavor: string, id: string, options?: any) {
        return EnginesApiFp(this.configuration).deleteOryAccessControlPolicy(flavor, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
     * @summary Delete an ORY Access Control Policy Role
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
     * @param {string} id The ID of the ORY Access Control Policy Role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public deleteOryAccessControlPolicyRole(flavor: string, id: string, options?: any) {
        return EnginesApiFp(this.configuration).deleteOryAccessControlPolicyRole(flavor, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to check if a request is allowed or not. If the request is allowed, a 200 response with `{\"allowed\":\"true\"}` will be sent. If the request is denied, a 403 response with `{\"allowed\":\"false\"}` will be sent instead.
     * @summary Check if a request is allowed
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
     * @param {OryAccessControlPolicyAllowedInput} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public doOryAccessControlPoliciesAllow(flavor: string, body?: OryAccessControlPolicyAllowedInput, options?: any) {
        return EnginesApiFp(this.configuration).doOryAccessControlPoliciesAllow(flavor, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an ORY Access Control Policy
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
     * @param {string} id The ID of the ORY Access Control Policy Role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public getOryAccessControlPolicy(flavor: string, id: string, options?: any) {
        return EnginesApiFp(this.configuration).getOryAccessControlPolicy(flavor, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
     * @summary Get an ORY Access Control Policy Role
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
     * @param {string} id The ID of the ORY Access Control Policy Role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public getOryAccessControlPolicyRole(flavor: string, id: string, options?: any) {
        return EnginesApiFp(this.configuration).getOryAccessControlPolicyRole(flavor, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List ORY Access Control Policies
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;
     * @param {number} [limit] The maximum amount of policies returned.
     * @param {number} [offset] The offset from where to start looking.
     * @param {string} [subject] The subject for whom the policies are to be listed.
     * @param {string} [resource] The resource for which the policies are to be listed.
     * @param {string} [action] The action for which policies are to be listed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public listOryAccessControlPolicies(flavor: string, limit?: number, offset?: number, subject?: string, resource?: string, action?: string, options?: any) {
        return EnginesApiFp(this.configuration).listOryAccessControlPolicies(flavor, limit, offset, subject, resource, action, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
     * @summary List ORY Access Control Policy Roles
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;
     * @param {number} [limit] The maximum amount of policies returned.
     * @param {number} [offset] The offset from where to start looking.
     * @param {string} [member] The member for which the roles are to be listed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public listOryAccessControlPolicyRoles(flavor: string, limit?: number, offset?: number, member?: string, options?: any) {
        return EnginesApiFp(this.configuration).listOryAccessControlPolicyRoles(flavor, limit, offset, member, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
     * @summary Remove a member from an ORY Access Control Policy Role
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
     * @param {string} id The ID of the ORY Access Control Policy Role.
     * @param {string} member The member to be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public removeOryAccessControlPolicyRoleMembers(flavor: string, id: string, member: string, options?: any) {
        return EnginesApiFp(this.configuration).removeOryAccessControlPolicyRoleMembers(flavor, id, member, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upsert an ORY Access Control Policy
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
     * @param {OryAccessControlPolicy} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public upsertOryAccessControlPolicy(flavor: string, body?: OryAccessControlPolicy, options?: any) {
        return EnginesApiFp(this.configuration).upsertOryAccessControlPolicy(flavor, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Roles group several subjects into one. Rules can be assigned to ORY Access Control Policy (OACP) by using the Role ID as subject in the OACP.
     * @summary Upsert an ORY Access Control Policy Role
     * @param {string} flavor The ORY Access Control Policy flavor. Can be \&quot;regex\&quot;, \&quot;glob\&quot;, and \&quot;exact\&quot;.
     * @param {OryAccessControlPolicyRole} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnginesApi
     */
    public upsertOryAccessControlPolicyRole(flavor: string, body?: OryAccessControlPolicyRole, options?: any) {
        return EnginesApiFp(this.configuration).upsertOryAccessControlPolicyRole(flavor, body, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check alive status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isInstanceAlive: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/alive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check readiness status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isInstanceReady: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/ready`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check alive status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isInstanceAlive(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await HealthApiAxiosParamCreator(configuration).isInstanceAlive(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check readiness status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isInstanceReady(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await HealthApiAxiosParamCreator(configuration).isInstanceReady(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check alive status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isInstanceAlive(options?: any): AxiosPromise<HealthStatus> {
            return HealthApiFp(configuration).isInstanceAlive(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check readiness status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isInstanceReady(options?: any): AxiosPromise<HealthStatus> {
            return HealthApiFp(configuration).isInstanceReady(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI {
    /**
     * This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
     * @summary Check alive status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public isInstanceAlive(options?: any) {
        return HealthApiFp(this.configuration).isInstanceAlive(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
     * @summary Check readiness status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public isInstanceReady(options?: any) {
        return HealthApiFp(this.configuration).isInstanceReady(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VersionApi - axios parameter creator
 * @export
 */
export const VersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Get service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionApi - functional programming interface
 * @export
 */
export const VersionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Get service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Version>> {
            const localVarAxiosArgs = await VersionApiAxiosParamCreator(configuration).getVersion(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VersionApi - factory interface
 * @export
 */
export const VersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Get service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: any): AxiosPromise<Version> {
            return VersionApiFp(configuration).getVersion(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersionApi - object-oriented interface
 * @export
 * @class VersionApi
 * @extends {BaseAPI}
 */
export class VersionApi extends BaseAPI {
    /**
     * This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
     * @summary Get service version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public getVersion(options?: any) {
        return VersionApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
    }
}


