/* tslint:disable */
/* eslint-disable */
/**
 * Ory Keto API
 * Documentation for all of Ory Keto\'s REST APIs. gRPC is documented separately. 
 *
 * The version of the OpenAPI document: v0.8.0-alpha.2
 * Contact: hi@ory.sh
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ExpandTree
 */
export interface ExpandTree {
    /**
     * 
     * @type {Array<ExpandTree>}
     * @memberof ExpandTree
     */
    'children'?: Array<ExpandTree>;
    /**
     * 
     * @type {string}
     * @memberof ExpandTree
     */
    'subject_id'?: string;
    /**
     * 
     * @type {SubjectSet}
     * @memberof ExpandTree
     */
    'subject_set'?: SubjectSet;
    /**
     * 
     * @type {string}
     * @memberof ExpandTree
     */
    'type': ExpandTreeTypeEnum;
}

export const ExpandTreeTypeEnum = {
    Union: 'union',
    Exclusion: 'exclusion',
    Intersection: 'intersection',
    Leaf: 'leaf'
} as const;

export type ExpandTreeTypeEnum = typeof ExpandTreeTypeEnum[keyof typeof ExpandTreeTypeEnum];

/**
 * The standard error format
 * @export
 * @interface GenericError
 */
export interface GenericError {
    /**
     * 
     * @type {number}
     * @memberof GenericError
     */
    'code'?: number;
    /**
     * 
     * @type {Array<{ [key: string]: object; }>}
     * @memberof GenericError
     */
    'details'?: Array<{ [key: string]: object; }>;
    /**
     * 
     * @type {string}
     * @memberof GenericError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericError
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericError
     */
    'request'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericError
     */
    'status'?: string;
}
/**
 * The content of the allowed field is mirrored in the HTTP status code.
 * @export
 * @interface GetCheckResponse
 */
export interface GetCheckResponse {
    /**
     * whether the relation tuple is allowed
     * @type {boolean}
     * @memberof GetCheckResponse
     */
    'allowed': boolean;
}
/**
 * 
 * @export
 * @interface GetRelationTuplesResponse
 */
export interface GetRelationTuplesResponse {
    /**
     * The opaque token to provide in a subsequent request to get the next page. It is the empty string iff this is the last page.
     * @type {string}
     * @memberof GetRelationTuplesResponse
     */
    'next_page_token'?: string;
    /**
     * 
     * @type {Array<InternalRelationTuple>}
     * @memberof GetRelationTuplesResponse
     */
    'relation_tuples'?: Array<InternalRelationTuple>;
}
/**
 * 
 * @export
 * @interface HealthNotReadyStatus
 */
export interface HealthNotReadyStatus {
    /**
     * Errors contains a list of errors that caused the not ready status.
     * @type {{ [key: string]: string; }}
     * @memberof HealthNotReadyStatus
     */
    'errors'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface HealthStatus
 */
export interface HealthStatus {
    /**
     * Status always contains \"ok\".
     * @type {string}
     * @memberof HealthStatus
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * Always \"ok\".
     * @type {string}
     * @memberof InlineResponse200
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * The version of Ory Keto.
     * @type {string}
     * @memberof InlineResponse2001
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface InlineResponse503
 */
export interface InlineResponse503 {
    /**
     * Errors contains a list of errors that caused the not ready status.
     * @type {{ [key: string]: string; }}
     * @memberof InlineResponse503
     */
    'errors': { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface InternalRelationTuple
 */
export interface InternalRelationTuple {
    /**
     * Namespace of the Relation Tuple
     * @type {string}
     * @memberof InternalRelationTuple
     */
    'namespace': string;
    /**
     * Object of the Relation Tuple
     * @type {string}
     * @memberof InternalRelationTuple
     */
    'object': string;
    /**
     * Relation of the Relation Tuple
     * @type {string}
     * @memberof InternalRelationTuple
     */
    'relation': string;
    /**
     * SubjectID of the Relation Tuple  Either SubjectSet or SubjectID are required.
     * @type {string}
     * @memberof InternalRelationTuple
     */
    'subject_id'?: string;
    /**
     * 
     * @type {SubjectSet}
     * @memberof InternalRelationTuple
     */
    'subject_set'?: SubjectSet;
}
/**
 * 
 * @export
 * @interface PatchDelta
 */
export interface PatchDelta {
    /**
     * 
     * @type {string}
     * @memberof PatchDelta
     */
    'action'?: PatchDeltaActionEnum;
    /**
     * 
     * @type {InternalRelationTuple}
     * @memberof PatchDelta
     */
    'relation_tuple'?: InternalRelationTuple;
}

export const PatchDeltaActionEnum = {
    Insert: 'insert',
    Delete: 'delete'
} as const;

export type PatchDeltaActionEnum = typeof PatchDeltaActionEnum[keyof typeof PatchDeltaActionEnum];

/**
 * 
 * @export
 * @interface RelationQuery
 */
export interface RelationQuery {
    /**
     * Namespace of the Relation Tuple
     * @type {string}
     * @memberof RelationQuery
     */
    'namespace'?: string;
    /**
     * Object of the Relation Tuple
     * @type {string}
     * @memberof RelationQuery
     */
    'object'?: string;
    /**
     * Relation of the Relation Tuple
     * @type {string}
     * @memberof RelationQuery
     */
    'relation'?: string;
    /**
     * SubjectID of the Relation Tuple  Either SubjectSet or SubjectID can be provided.
     * @type {string}
     * @memberof RelationQuery
     */
    'subject_id'?: string;
    /**
     * 
     * @type {SubjectSet}
     * @memberof RelationQuery
     */
    'subject_set'?: SubjectSet;
}
/**
 * 
 * @export
 * @interface SubjectSet
 */
export interface SubjectSet {
    /**
     * Namespace of the Subject Set
     * @type {string}
     * @memberof SubjectSet
     */
    'namespace': string;
    /**
     * Object of the Subject Set
     * @type {string}
     * @memberof SubjectSet
     */
    'object': string;
    /**
     * Relation of the Subject Set
     * @type {string}
     * @memberof SubjectSet
     */
    'relation': string;
}
/**
 * 
 * @export
 * @interface Version
 */
export interface Version {
    /**
     * Version is the service\'s version.
     * @type {string}
     * @memberof Version
     */
    'version'?: string;
}

/**
 * MetadataApi - axios parameter creator
 * @export
 */
export const MetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns the version of Ory Keto.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the version will never refer to the cluster state, only to a single instance.
         * @summary Return Running Software Version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a HTTP 200 status code when Ory Keto is accepting incoming HTTP requests. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check HTTP Server Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAlive: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/alive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a HTTP 200 status code when Ory Keto is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of Ory Keto, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check HTTP Server and Database Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isReady: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/ready`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetadataApi - functional programming interface
 * @export
 */
export const MetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns the version of Ory Keto.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the version will never refer to the cluster state, only to a single instance.
         * @summary Return Running Software Version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a HTTP 200 status code when Ory Keto is accepting incoming HTTP requests. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check HTTP Server Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isAlive(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isAlive(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a HTTP 200 status code when Ory Keto is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of Ory Keto, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check HTTP Server and Database Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isReady(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isReady(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetadataApi - factory interface
 * @export
 */
export const MetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetadataApiFp(configuration)
    return {
        /**
         * This endpoint returns the version of Ory Keto.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the version will never refer to the cluster state, only to a single instance.
         * @summary Return Running Software Version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.getVersion(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a HTTP 200 status code when Ory Keto is accepting incoming HTTP requests. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check HTTP Server Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isAlive(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.isAlive(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a HTTP 200 status code when Ory Keto is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of Ory Keto, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check HTTP Server and Database Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isReady(options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.isReady(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetadataApi - interface
 * @export
 * @interface MetadataApi
 */
export interface MetadataApiInterface {
    /**
     * This endpoint returns the version of Ory Keto.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the version will never refer to the cluster state, only to a single instance.
     * @summary Return Running Software Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApiInterface
     */
    getVersion(options?: AxiosRequestConfig): AxiosPromise<InlineResponse2001>;

    /**
     * This endpoint returns a HTTP 200 status code when Ory Keto is accepting incoming HTTP requests. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
     * @summary Check HTTP Server Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApiInterface
     */
    isAlive(options?: AxiosRequestConfig): AxiosPromise<InlineResponse200>;

    /**
     * This endpoint returns a HTTP 200 status code when Ory Keto is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of Ory Keto, the health status will never refer to the cluster state, only to a single instance.
     * @summary Check HTTP Server and Database Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApiInterface
     */
    isReady(options?: AxiosRequestConfig): AxiosPromise<InlineResponse200>;

}

/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
export class MetadataApi extends BaseAPI implements MetadataApiInterface {
    /**
     * This endpoint returns the version of Ory Keto.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the version will never refer to the cluster state, only to a single instance.
     * @summary Return Running Software Version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public getVersion(options?: AxiosRequestConfig) {
        return MetadataApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a HTTP 200 status code when Ory Keto is accepting incoming HTTP requests. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
     * @summary Check HTTP Server Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public isAlive(options?: AxiosRequestConfig) {
        return MetadataApiFp(this.configuration).isAlive(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a HTTP 200 status code when Ory Keto is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of Ory Keto, the health status will never refer to the cluster state, only to a single instance.
     * @summary Check HTTP Server and Database Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public isReady(options?: AxiosRequestConfig) {
        return MetadataApiFp(this.configuration).isReady(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReadApi - axios parameter creator
 * @export
 */
export const ReadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
         * @summary Check a relation tuple
         * @param {string} [namespace] Namespace of the Relation Tuple
         * @param {string} [object] Object of the Relation Tuple
         * @param {string} [relation] Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheck: async (namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, maxDepth?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subject_id'] = subjectId;
            }

            if (subjectSetNamespace !== undefined) {
                localVarQueryParameter['subject_set.namespace'] = subjectSetNamespace;
            }

            if (subjectSetObject !== undefined) {
                localVarQueryParameter['subject_set.object'] = subjectSetObject;
            }

            if (subjectSetRelation !== undefined) {
                localVarQueryParameter['subject_set.relation'] = subjectSetRelation;
            }

            if (maxDepth !== undefined) {
                localVarQueryParameter['max-depth'] = maxDepth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to expand a relation tuple.
         * @summary Expand a Relation Tuple
         * @param {string} namespace Namespace of the Subject Set
         * @param {string} object Object of the Subject Set
         * @param {string} relation Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpand: async (namespace: string, object: string, relation: string, maxDepth?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'namespace' is not null or undefined
            assertParamExists('getExpand', 'namespace', namespace)
            // verify required parameter 'object' is not null or undefined
            assertParamExists('getExpand', 'object', object)
            // verify required parameter 'relation' is not null or undefined
            assertParamExists('getExpand', 'relation', relation)
            const localVarPath = `/expand`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }

            if (maxDepth !== undefined) {
                localVarQueryParameter['max-depth'] = maxDepth;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all relation tuples that match the query. Only the namespace field is required.
         * @summary Query relation tuples
         * @param {string} [pageToken] 
         * @param {number} [pageSize] 
         * @param {string} [namespace] Namespace of the Relation Tuple
         * @param {string} [object] Object of the Relation Tuple
         * @param {string} [relation] Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationTuples: async (pageToken?: string, pageSize?: number, namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/relation-tuples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageToken !== undefined) {
                localVarQueryParameter['page_token'] = pageToken;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subject_id'] = subjectId;
            }

            if (subjectSetNamespace !== undefined) {
                localVarQueryParameter['subject_set.namespace'] = subjectSetNamespace;
            }

            if (subjectSetObject !== undefined) {
                localVarQueryParameter['subject_set.object'] = subjectSetObject;
            }

            if (subjectSetRelation !== undefined) {
                localVarQueryParameter['subject_set.relation'] = subjectSetRelation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
         * @summary Check a relation tuple
         * @param {number} [maxDepth] 
         * @param {RelationQuery} [relationQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCheck: async (maxDepth?: number, relationQuery?: RelationQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (maxDepth !== undefined) {
                localVarQueryParameter['max-depth'] = maxDepth;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(relationQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReadApi - functional programming interface
 * @export
 */
export const ReadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReadApiAxiosParamCreator(configuration)
    return {
        /**
         * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
         * @summary Check a relation tuple
         * @param {string} [namespace] Namespace of the Relation Tuple
         * @param {string} [object] Object of the Relation Tuple
         * @param {string} [relation] Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCheck(namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, maxDepth?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCheck(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, maxDepth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to expand a relation tuple.
         * @summary Expand a Relation Tuple
         * @param {string} namespace Namespace of the Subject Set
         * @param {string} object Object of the Subject Set
         * @param {string} relation Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpand(namespace: string, object: string, relation: string, maxDepth?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExpandTree>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpand(namespace, object, relation, maxDepth, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all relation tuples that match the query. Only the namespace field is required.
         * @summary Query relation tuples
         * @param {string} [pageToken] 
         * @param {number} [pageSize] 
         * @param {string} [namespace] Namespace of the Relation Tuple
         * @param {string} [object] Object of the Relation Tuple
         * @param {string} [relation] Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRelationTuples(pageToken?: string, pageSize?: number, namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRelationTuplesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRelationTuples(pageToken, pageSize, namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
         * @summary Check a relation tuple
         * @param {number} [maxDepth] 
         * @param {RelationQuery} [relationQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCheck(maxDepth?: number, relationQuery?: RelationQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCheck(maxDepth, relationQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReadApi - factory interface
 * @export
 */
export const ReadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReadApiFp(configuration)
    return {
        /**
         * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
         * @summary Check a relation tuple
         * @param {string} [namespace] Namespace of the Relation Tuple
         * @param {string} [object] Object of the Relation Tuple
         * @param {string} [relation] Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheck(namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, maxDepth?: number, options?: any): AxiosPromise<GetCheckResponse> {
            return localVarFp.getCheck(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, maxDepth, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to expand a relation tuple.
         * @summary Expand a Relation Tuple
         * @param {string} namespace Namespace of the Subject Set
         * @param {string} object Object of the Subject Set
         * @param {string} relation Relation of the Subject Set
         * @param {number} [maxDepth] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpand(namespace: string, object: string, relation: string, maxDepth?: number, options?: any): AxiosPromise<ExpandTree> {
            return localVarFp.getExpand(namespace, object, relation, maxDepth, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all relation tuples that match the query. Only the namespace field is required.
         * @summary Query relation tuples
         * @param {string} [pageToken] 
         * @param {number} [pageSize] 
         * @param {string} [namespace] Namespace of the Relation Tuple
         * @param {string} [object] Object of the Relation Tuple
         * @param {string} [relation] Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRelationTuples(pageToken?: string, pageSize?: number, namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: any): AxiosPromise<GetRelationTuplesResponse> {
            return localVarFp.getRelationTuples(pageToken, pageSize, namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, options).then((request) => request(axios, basePath));
        },
        /**
         * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
         * @summary Check a relation tuple
         * @param {number} [maxDepth] 
         * @param {RelationQuery} [relationQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCheck(maxDepth?: number, relationQuery?: RelationQuery, options?: any): AxiosPromise<GetCheckResponse> {
            return localVarFp.postCheck(maxDepth, relationQuery, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReadApi - interface
 * @export
 * @interface ReadApi
 */
export interface ReadApiInterface {
    /**
     * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
     * @summary Check a relation tuple
     * @param {string} [namespace] Namespace of the Relation Tuple
     * @param {string} [object] Object of the Relation Tuple
     * @param {string} [relation] Relation of the Relation Tuple
     * @param {string} [subjectId] SubjectID of the Relation Tuple
     * @param {string} [subjectSetNamespace] Namespace of the Subject Set
     * @param {string} [subjectSetObject] Object of the Subject Set
     * @param {string} [subjectSetRelation] Relation of the Subject Set
     * @param {number} [maxDepth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApiInterface
     */
    getCheck(namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, maxDepth?: number, options?: AxiosRequestConfig): AxiosPromise<GetCheckResponse>;

    /**
     * Use this endpoint to expand a relation tuple.
     * @summary Expand a Relation Tuple
     * @param {string} namespace Namespace of the Subject Set
     * @param {string} object Object of the Subject Set
     * @param {string} relation Relation of the Subject Set
     * @param {number} [maxDepth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApiInterface
     */
    getExpand(namespace: string, object: string, relation: string, maxDepth?: number, options?: AxiosRequestConfig): AxiosPromise<ExpandTree>;

    /**
     * Get all relation tuples that match the query. Only the namespace field is required.
     * @summary Query relation tuples
     * @param {string} [pageToken] 
     * @param {number} [pageSize] 
     * @param {string} [namespace] Namespace of the Relation Tuple
     * @param {string} [object] Object of the Relation Tuple
     * @param {string} [relation] Relation of the Relation Tuple
     * @param {string} [subjectId] SubjectID of the Relation Tuple
     * @param {string} [subjectSetNamespace] Namespace of the Subject Set
     * @param {string} [subjectSetObject] Object of the Subject Set
     * @param {string} [subjectSetRelation] Relation of the Subject Set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApiInterface
     */
    getRelationTuples(pageToken?: string, pageSize?: number, namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: AxiosRequestConfig): AxiosPromise<GetRelationTuplesResponse>;

    /**
     * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
     * @summary Check a relation tuple
     * @param {number} [maxDepth] 
     * @param {RelationQuery} [relationQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApiInterface
     */
    postCheck(maxDepth?: number, relationQuery?: RelationQuery, options?: AxiosRequestConfig): AxiosPromise<GetCheckResponse>;

}

/**
 * ReadApi - object-oriented interface
 * @export
 * @class ReadApi
 * @extends {BaseAPI}
 */
export class ReadApi extends BaseAPI implements ReadApiInterface {
    /**
     * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
     * @summary Check a relation tuple
     * @param {string} [namespace] Namespace of the Relation Tuple
     * @param {string} [object] Object of the Relation Tuple
     * @param {string} [relation] Relation of the Relation Tuple
     * @param {string} [subjectId] SubjectID of the Relation Tuple
     * @param {string} [subjectSetNamespace] Namespace of the Subject Set
     * @param {string} [subjectSetObject] Object of the Subject Set
     * @param {string} [subjectSetRelation] Relation of the Subject Set
     * @param {number} [maxDepth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApi
     */
    public getCheck(namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, maxDepth?: number, options?: AxiosRequestConfig) {
        return ReadApiFp(this.configuration).getCheck(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, maxDepth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to expand a relation tuple.
     * @summary Expand a Relation Tuple
     * @param {string} namespace Namespace of the Subject Set
     * @param {string} object Object of the Subject Set
     * @param {string} relation Relation of the Subject Set
     * @param {number} [maxDepth] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApi
     */
    public getExpand(namespace: string, object: string, relation: string, maxDepth?: number, options?: AxiosRequestConfig) {
        return ReadApiFp(this.configuration).getExpand(namespace, object, relation, maxDepth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all relation tuples that match the query. Only the namespace field is required.
     * @summary Query relation tuples
     * @param {string} [pageToken] 
     * @param {number} [pageSize] 
     * @param {string} [namespace] Namespace of the Relation Tuple
     * @param {string} [object] Object of the Relation Tuple
     * @param {string} [relation] Relation of the Relation Tuple
     * @param {string} [subjectId] SubjectID of the Relation Tuple
     * @param {string} [subjectSetNamespace] Namespace of the Subject Set
     * @param {string} [subjectSetObject] Object of the Subject Set
     * @param {string} [subjectSetRelation] Relation of the Subject Set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApi
     */
    public getRelationTuples(pageToken?: string, pageSize?: number, namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: AxiosRequestConfig) {
        return ReadApiFp(this.configuration).getRelationTuples(pageToken, pageSize, namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To learn how relation tuples and the check works, head over to [the documentation](../concepts/relation-tuples.mdx).
     * @summary Check a relation tuple
     * @param {number} [maxDepth] 
     * @param {RelationQuery} [relationQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReadApi
     */
    public postCheck(maxDepth?: number, relationQuery?: RelationQuery, options?: AxiosRequestConfig) {
        return ReadApiFp(this.configuration).postCheck(maxDepth, relationQuery, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WriteApi - axios parameter creator
 * @export
 */
export const WriteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this endpoint to create a relation tuple.
         * @summary Create a Relation Tuple
         * @param {RelationQuery} [relationQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelationTuple: async (relationQuery?: RelationQuery, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/relation-tuples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(relationQuery, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to delete relation tuples
         * @summary Delete Relation Tuples
         * @param {string} [namespace] Namespace of the Relation Tuple
         * @param {string} [object] Object of the Relation Tuple
         * @param {string} [relation] Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelationTuples: async (namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/relation-tuples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (relation !== undefined) {
                localVarQueryParameter['relation'] = relation;
            }

            if (subjectId !== undefined) {
                localVarQueryParameter['subject_id'] = subjectId;
            }

            if (subjectSetNamespace !== undefined) {
                localVarQueryParameter['subject_set.namespace'] = subjectSetNamespace;
            }

            if (subjectSetObject !== undefined) {
                localVarQueryParameter['subject_set.object'] = subjectSetObject;
            }

            if (subjectSetRelation !== undefined) {
                localVarQueryParameter['subject_set.relation'] = subjectSetRelation;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this endpoint to patch one or more relation tuples.
         * @summary Patch Multiple Relation Tuples
         * @param {Array<PatchDelta>} [patchDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRelationTuples: async (patchDelta?: Array<PatchDelta>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/relation-tuples`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchDelta, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WriteApi - functional programming interface
 * @export
 */
export const WriteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WriteApiAxiosParamCreator(configuration)
    return {
        /**
         * Use this endpoint to create a relation tuple.
         * @summary Create a Relation Tuple
         * @param {RelationQuery} [relationQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRelationTuple(relationQuery?: RelationQuery, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelationQuery>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRelationTuple(relationQuery, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to delete relation tuples
         * @summary Delete Relation Tuples
         * @param {string} [namespace] Namespace of the Relation Tuple
         * @param {string} [object] Object of the Relation Tuple
         * @param {string} [relation] Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRelationTuples(namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRelationTuples(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this endpoint to patch one or more relation tuples.
         * @summary Patch Multiple Relation Tuples
         * @param {Array<PatchDelta>} [patchDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRelationTuples(patchDelta?: Array<PatchDelta>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRelationTuples(patchDelta, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WriteApi - factory interface
 * @export
 */
export const WriteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WriteApiFp(configuration)
    return {
        /**
         * Use this endpoint to create a relation tuple.
         * @summary Create a Relation Tuple
         * @param {RelationQuery} [relationQuery] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRelationTuple(relationQuery?: RelationQuery, options?: any): AxiosPromise<RelationQuery> {
            return localVarFp.createRelationTuple(relationQuery, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to delete relation tuples
         * @summary Delete Relation Tuples
         * @param {string} [namespace] Namespace of the Relation Tuple
         * @param {string} [object] Object of the Relation Tuple
         * @param {string} [relation] Relation of the Relation Tuple
         * @param {string} [subjectId] SubjectID of the Relation Tuple
         * @param {string} [subjectSetNamespace] Namespace of the Subject Set
         * @param {string} [subjectSetObject] Object of the Subject Set
         * @param {string} [subjectSetRelation] Relation of the Subject Set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRelationTuples(namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRelationTuples(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this endpoint to patch one or more relation tuples.
         * @summary Patch Multiple Relation Tuples
         * @param {Array<PatchDelta>} [patchDelta] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRelationTuples(patchDelta?: Array<PatchDelta>, options?: any): AxiosPromise<void> {
            return localVarFp.patchRelationTuples(patchDelta, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WriteApi - interface
 * @export
 * @interface WriteApi
 */
export interface WriteApiInterface {
    /**
     * Use this endpoint to create a relation tuple.
     * @summary Create a Relation Tuple
     * @param {RelationQuery} [relationQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApiInterface
     */
    createRelationTuple(relationQuery?: RelationQuery, options?: AxiosRequestConfig): AxiosPromise<RelationQuery>;

    /**
     * Use this endpoint to delete relation tuples
     * @summary Delete Relation Tuples
     * @param {string} [namespace] Namespace of the Relation Tuple
     * @param {string} [object] Object of the Relation Tuple
     * @param {string} [relation] Relation of the Relation Tuple
     * @param {string} [subjectId] SubjectID of the Relation Tuple
     * @param {string} [subjectSetNamespace] Namespace of the Subject Set
     * @param {string} [subjectSetObject] Object of the Subject Set
     * @param {string} [subjectSetRelation] Relation of the Subject Set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApiInterface
     */
    deleteRelationTuples(namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Use this endpoint to patch one or more relation tuples.
     * @summary Patch Multiple Relation Tuples
     * @param {Array<PatchDelta>} [patchDelta] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApiInterface
     */
    patchRelationTuples(patchDelta?: Array<PatchDelta>, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * WriteApi - object-oriented interface
 * @export
 * @class WriteApi
 * @extends {BaseAPI}
 */
export class WriteApi extends BaseAPI implements WriteApiInterface {
    /**
     * Use this endpoint to create a relation tuple.
     * @summary Create a Relation Tuple
     * @param {RelationQuery} [relationQuery] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApi
     */
    public createRelationTuple(relationQuery?: RelationQuery, options?: AxiosRequestConfig) {
        return WriteApiFp(this.configuration).createRelationTuple(relationQuery, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to delete relation tuples
     * @summary Delete Relation Tuples
     * @param {string} [namespace] Namespace of the Relation Tuple
     * @param {string} [object] Object of the Relation Tuple
     * @param {string} [relation] Relation of the Relation Tuple
     * @param {string} [subjectId] SubjectID of the Relation Tuple
     * @param {string} [subjectSetNamespace] Namespace of the Subject Set
     * @param {string} [subjectSetObject] Object of the Subject Set
     * @param {string} [subjectSetRelation] Relation of the Subject Set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApi
     */
    public deleteRelationTuples(namespace?: string, object?: string, relation?: string, subjectId?: string, subjectSetNamespace?: string, subjectSetObject?: string, subjectSetRelation?: string, options?: AxiosRequestConfig) {
        return WriteApiFp(this.configuration).deleteRelationTuples(namespace, object, relation, subjectId, subjectSetNamespace, subjectSetObject, subjectSetRelation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this endpoint to patch one or more relation tuples.
     * @summary Patch Multiple Relation Tuples
     * @param {Array<PatchDelta>} [patchDelta] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WriteApi
     */
    public patchRelationTuples(patchDelta?: Array<PatchDelta>, options?: AxiosRequestConfig) {
        return WriteApiFp(this.configuration).patchRelationTuples(patchDelta, options).then((request) => request(this.axios, this.basePath));
    }
}


