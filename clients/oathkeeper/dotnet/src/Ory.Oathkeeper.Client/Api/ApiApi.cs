/*
 * ORY Oathkeeper
 *
 * ORY Oathkeeper is a reverse proxy that checks the HTTP Authorization for validity against a set of rules. This service uses Hydra to validate access tokens and policies.
 *
 * The version of the OpenAPI document: v0.0.0-alpha.45
 * Contact: hi@ory.am
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using Ory.Oathkeeper.Client.Client;
using Ory.Oathkeeper.Client.Model;

namespace Ory.Oathkeeper.Client.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IApiApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Access Control Decision API
        /// </summary>
        /// <remarks>
        /// &gt; This endpoint works with all HTTP Methods (GET, POST, PUT, ...) and matches every path prefixed with /decision.  This endpoint mirrors the proxy capability of ORY Oathkeeper&#39;s proxy functionality but instead of forwarding the request to the upstream server, returns 200 (request should be allowed), 401 (unauthorized), or 403 (forbidden) status codes. This endpoint can be used to integrate with other API Proxies like Ambassador, Kong, Envoy, and many more.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns></returns>
        void Decisions();

        /// <summary>
        /// Access Control Decision API
        /// </summary>
        /// <remarks>
        /// &gt; This endpoint works with all HTTP Methods (GET, POST, PUT, ...) and matches every path prefixed with /decision.  This endpoint mirrors the proxy capability of ORY Oathkeeper&#39;s proxy functionality but instead of forwarding the request to the upstream server, returns 200 (request should be allowed), 401 (unauthorized), or 403 (forbidden) status codes. This endpoint can be used to integrate with other API Proxies like Ambassador, Kong, Envoy, and many more.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DecisionsWithHttpInfo();
        /// <summary>
        /// Retrieve a rule
        /// </summary>
        /// <remarks>
        /// Use this method to retrieve a rule from the storage. If it does not exist you will receive a 404 error.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>OathkeeperRule</returns>
        OathkeeperRule GetRule(string id);

        /// <summary>
        /// Retrieve a rule
        /// </summary>
        /// <remarks>
        /// Use this method to retrieve a rule from the storage. If it does not exist you will receive a 404 error.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>ApiResponse of OathkeeperRule</returns>
        ApiResponse<OathkeeperRule> GetRuleWithHttpInfo(string id);
        /// <summary>
        /// Get service version
        /// </summary>
        /// <remarks>
        /// This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>OathkeeperVersion</returns>
        OathkeeperVersion GetVersion();

        /// <summary>
        /// Get service version
        /// </summary>
        /// <remarks>
        /// This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of OathkeeperVersion</returns>
        ApiResponse<OathkeeperVersion> GetVersionWithHttpInfo();
        /// <summary>
        /// Lists cryptographic keys
        /// </summary>
        /// <remarks>
        /// This endpoint returns cryptographic keys that are required to, for example, verify signatures of ID Tokens.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>OathkeeperJsonWebKeySet</returns>
        OathkeeperJsonWebKeySet GetWellKnownJSONWebKeys();

        /// <summary>
        /// Lists cryptographic keys
        /// </summary>
        /// <remarks>
        /// This endpoint returns cryptographic keys that are required to, for example, verify signatures of ID Tokens.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of OathkeeperJsonWebKeySet</returns>
        ApiResponse<OathkeeperJsonWebKeySet> GetWellKnownJSONWebKeysWithHttpInfo();
        /// <summary>
        /// Check alive status
        /// </summary>
        /// <remarks>
        /// This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>OathkeeperHealthStatus</returns>
        OathkeeperHealthStatus IsInstanceAlive();

        /// <summary>
        /// Check alive status
        /// </summary>
        /// <remarks>
        /// This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of OathkeeperHealthStatus</returns>
        ApiResponse<OathkeeperHealthStatus> IsInstanceAliveWithHttpInfo();
        /// <summary>
        /// Check readiness status
        /// </summary>
        /// <remarks>
        /// This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>OathkeeperHealthStatus</returns>
        OathkeeperHealthStatus IsInstanceReady();

        /// <summary>
        /// Check readiness status
        /// </summary>
        /// <remarks>
        /// This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of OathkeeperHealthStatus</returns>
        ApiResponse<OathkeeperHealthStatus> IsInstanceReadyWithHttpInfo();
        /// <summary>
        /// List all rules
        /// </summary>
        /// <remarks>
        /// This method returns an array of all rules that are stored in the backend. This is useful if you want to get a full view of what rules you have currently in place.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">The maximum amount of rules returned. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <returns>List&lt;OathkeeperRule&gt;</returns>
        List<OathkeeperRule> ListRules(long? limit = default(long?), long? offset = default(long?));

        /// <summary>
        /// List all rules
        /// </summary>
        /// <remarks>
        /// This method returns an array of all rules that are stored in the backend. This is useful if you want to get a full view of what rules you have currently in place.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">The maximum amount of rules returned. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <returns>ApiResponse of List&lt;OathkeeperRule&gt;</returns>
        ApiResponse<List<OathkeeperRule>> ListRulesWithHttpInfo(long? limit = default(long?), long? offset = default(long?));
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IApiApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Access Control Decision API
        /// </summary>
        /// <remarks>
        /// &gt; This endpoint works with all HTTP Methods (GET, POST, PUT, ...) and matches every path prefixed with /decision.  This endpoint mirrors the proxy capability of ORY Oathkeeper&#39;s proxy functionality but instead of forwarding the request to the upstream server, returns 200 (request should be allowed), 401 (unauthorized), or 403 (forbidden) status codes. This endpoint can be used to integrate with other API Proxies like Ambassador, Kong, Envoy, and many more.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DecisionsAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Access Control Decision API
        /// </summary>
        /// <remarks>
        /// &gt; This endpoint works with all HTTP Methods (GET, POST, PUT, ...) and matches every path prefixed with /decision.  This endpoint mirrors the proxy capability of ORY Oathkeeper&#39;s proxy functionality but instead of forwarding the request to the upstream server, returns 200 (request should be allowed), 401 (unauthorized), or 403 (forbidden) status codes. This endpoint can be used to integrate with other API Proxies like Ambassador, Kong, Envoy, and many more.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DecisionsWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Retrieve a rule
        /// </summary>
        /// <remarks>
        /// Use this method to retrieve a rule from the storage. If it does not exist you will receive a 404 error.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of OathkeeperRule</returns>
        System.Threading.Tasks.Task<OathkeeperRule> GetRuleAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Retrieve a rule
        /// </summary>
        /// <remarks>
        /// Use this method to retrieve a rule from the storage. If it does not exist you will receive a 404 error.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (OathkeeperRule)</returns>
        System.Threading.Tasks.Task<ApiResponse<OathkeeperRule>> GetRuleWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get service version
        /// </summary>
        /// <remarks>
        /// This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of OathkeeperVersion</returns>
        System.Threading.Tasks.Task<OathkeeperVersion> GetVersionAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get service version
        /// </summary>
        /// <remarks>
        /// This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (OathkeeperVersion)</returns>
        System.Threading.Tasks.Task<ApiResponse<OathkeeperVersion>> GetVersionWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Lists cryptographic keys
        /// </summary>
        /// <remarks>
        /// This endpoint returns cryptographic keys that are required to, for example, verify signatures of ID Tokens.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of OathkeeperJsonWebKeySet</returns>
        System.Threading.Tasks.Task<OathkeeperJsonWebKeySet> GetWellKnownJSONWebKeysAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Lists cryptographic keys
        /// </summary>
        /// <remarks>
        /// This endpoint returns cryptographic keys that are required to, for example, verify signatures of ID Tokens.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (OathkeeperJsonWebKeySet)</returns>
        System.Threading.Tasks.Task<ApiResponse<OathkeeperJsonWebKeySet>> GetWellKnownJSONWebKeysWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Check alive status
        /// </summary>
        /// <remarks>
        /// This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of OathkeeperHealthStatus</returns>
        System.Threading.Tasks.Task<OathkeeperHealthStatus> IsInstanceAliveAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Check alive status
        /// </summary>
        /// <remarks>
        /// This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (OathkeeperHealthStatus)</returns>
        System.Threading.Tasks.Task<ApiResponse<OathkeeperHealthStatus>> IsInstanceAliveWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Check readiness status
        /// </summary>
        /// <remarks>
        /// This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of OathkeeperHealthStatus</returns>
        System.Threading.Tasks.Task<OathkeeperHealthStatus> IsInstanceReadyAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Check readiness status
        /// </summary>
        /// <remarks>
        /// This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (OathkeeperHealthStatus)</returns>
        System.Threading.Tasks.Task<ApiResponse<OathkeeperHealthStatus>> IsInstanceReadyWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// List all rules
        /// </summary>
        /// <remarks>
        /// This method returns an array of all rules that are stored in the backend. This is useful if you want to get a full view of what rules you have currently in place.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">The maximum amount of rules returned. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;OathkeeperRule&gt;</returns>
        System.Threading.Tasks.Task<List<OathkeeperRule>> ListRulesAsync(long? limit = default(long?), long? offset = default(long?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// List all rules
        /// </summary>
        /// <remarks>
        /// This method returns an array of all rules that are stored in the backend. This is useful if you want to get a full view of what rules you have currently in place.
        /// </remarks>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">The maximum amount of rules returned. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;OathkeeperRule&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<OathkeeperRule>>> ListRulesWithHttpInfoAsync(long? limit = default(long?), long? offset = default(long?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IApiApi : IApiApiSync, IApiApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class ApiApi : IApiApi
    {
        private Ory.Oathkeeper.Client.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="ApiApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ApiApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ApiApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ApiApi(string basePath)
        {
            this.Configuration = Ory.Oathkeeper.Client.Client.Configuration.MergeConfigurations(
                Ory.Oathkeeper.Client.Client.GlobalConfiguration.Instance,
                new Ory.Oathkeeper.Client.Client.Configuration { BasePath = basePath }
            );
            this.Client = new Ory.Oathkeeper.Client.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Ory.Oathkeeper.Client.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Ory.Oathkeeper.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ApiApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public ApiApi(Ory.Oathkeeper.Client.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Ory.Oathkeeper.Client.Client.Configuration.MergeConfigurations(
                Ory.Oathkeeper.Client.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new Ory.Oathkeeper.Client.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Ory.Oathkeeper.Client.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Ory.Oathkeeper.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="ApiApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public ApiApi(Ory.Oathkeeper.Client.Client.ISynchronousClient client, Ory.Oathkeeper.Client.Client.IAsynchronousClient asyncClient, Ory.Oathkeeper.Client.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Ory.Oathkeeper.Client.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Ory.Oathkeeper.Client.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Ory.Oathkeeper.Client.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Ory.Oathkeeper.Client.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Ory.Oathkeeper.Client.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Access Control Decision API &gt; This endpoint works with all HTTP Methods (GET, POST, PUT, ...) and matches every path prefixed with /decision.  This endpoint mirrors the proxy capability of ORY Oathkeeper&#39;s proxy functionality but instead of forwarding the request to the upstream server, returns 200 (request should be allowed), 401 (unauthorized), or 403 (forbidden) status codes. This endpoint can be used to integrate with other API Proxies like Ambassador, Kong, Envoy, and many more.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns></returns>
        public void Decisions()
        {
            DecisionsWithHttpInfo();
        }

        /// <summary>
        /// Access Control Decision API &gt; This endpoint works with all HTTP Methods (GET, POST, PUT, ...) and matches every path prefixed with /decision.  This endpoint mirrors the proxy capability of ORY Oathkeeper&#39;s proxy functionality but instead of forwarding the request to the upstream server, returns 200 (request should be allowed), 401 (unauthorized), or 403 (forbidden) status codes. This endpoint can be used to integrate with other API Proxies like Ambassador, Kong, Envoy, and many more.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of Object(void)</returns>
        public Ory.Oathkeeper.Client.Client.ApiResponse<Object> DecisionsWithHttpInfo()
        {
            Ory.Oathkeeper.Client.Client.RequestOptions localVarRequestOptions = new Ory.Oathkeeper.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);



            // make the HTTP request
            var localVarResponse = this.Client.Get<Object>("/decisions", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("Decisions", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Access Control Decision API &gt; This endpoint works with all HTTP Methods (GET, POST, PUT, ...) and matches every path prefixed with /decision.  This endpoint mirrors the proxy capability of ORY Oathkeeper&#39;s proxy functionality but instead of forwarding the request to the upstream server, returns 200 (request should be allowed), 401 (unauthorized), or 403 (forbidden) status codes. This endpoint can be used to integrate with other API Proxies like Ambassador, Kong, Envoy, and many more.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DecisionsAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DecisionsWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Access Control Decision API &gt; This endpoint works with all HTTP Methods (GET, POST, PUT, ...) and matches every path prefixed with /decision.  This endpoint mirrors the proxy capability of ORY Oathkeeper&#39;s proxy functionality but instead of forwarding the request to the upstream server, returns 200 (request should be allowed), 401 (unauthorized), or 403 (forbidden) status codes. This endpoint can be used to integrate with other API Proxies like Ambassador, Kong, Envoy, and many more.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Ory.Oathkeeper.Client.Client.ApiResponse<Object>> DecisionsWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Ory.Oathkeeper.Client.Client.RequestOptions localVarRequestOptions = new Ory.Oathkeeper.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);



            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<Object>("/decisions", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("Decisions", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve a rule Use this method to retrieve a rule from the storage. If it does not exist you will receive a 404 error.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>OathkeeperRule</returns>
        public OathkeeperRule GetRule(string id)
        {
            Ory.Oathkeeper.Client.Client.ApiResponse<OathkeeperRule> localVarResponse = GetRuleWithHttpInfo(id);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve a rule Use this method to retrieve a rule from the storage. If it does not exist you will receive a 404 error.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <returns>ApiResponse of OathkeeperRule</returns>
        public Ory.Oathkeeper.Client.Client.ApiResponse<OathkeeperRule> GetRuleWithHttpInfo(string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Ory.Oathkeeper.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ApiApi->GetRule");

            Ory.Oathkeeper.Client.Client.RequestOptions localVarRequestOptions = new Ory.Oathkeeper.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Ory.Oathkeeper.Client.Client.ClientUtils.ParameterToString(id)); // path parameter


            // make the HTTP request
            var localVarResponse = this.Client.Get<OathkeeperRule>("/rules/{id}", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRule", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Retrieve a rule Use this method to retrieve a rule from the storage. If it does not exist you will receive a 404 error.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of OathkeeperRule</returns>
        public async System.Threading.Tasks.Task<OathkeeperRule> GetRuleAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Oathkeeper.Client.Client.ApiResponse<OathkeeperRule> localVarResponse = await GetRuleWithHttpInfoAsync(id, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Retrieve a rule Use this method to retrieve a rule from the storage. If it does not exist you will receive a 404 error.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id"></param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (OathkeeperRule)</returns>
        public async System.Threading.Tasks.Task<Ory.Oathkeeper.Client.Client.ApiResponse<OathkeeperRule>> GetRuleWithHttpInfoAsync(string id, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new Ory.Oathkeeper.Client.Client.ApiException(400, "Missing required parameter 'id' when calling ApiApi->GetRule");


            Ory.Oathkeeper.Client.Client.RequestOptions localVarRequestOptions = new Ory.Oathkeeper.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            localVarRequestOptions.PathParameters.Add("id", Ory.Oathkeeper.Client.Client.ClientUtils.ParameterToString(id)); // path parameter


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<OathkeeperRule>("/rules/{id}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetRule", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get service version This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>OathkeeperVersion</returns>
        public OathkeeperVersion GetVersion()
        {
            Ory.Oathkeeper.Client.Client.ApiResponse<OathkeeperVersion> localVarResponse = GetVersionWithHttpInfo();
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get service version This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of OathkeeperVersion</returns>
        public Ory.Oathkeeper.Client.Client.ApiResponse<OathkeeperVersion> GetVersionWithHttpInfo()
        {
            Ory.Oathkeeper.Client.Client.RequestOptions localVarRequestOptions = new Ory.Oathkeeper.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);



            // make the HTTP request
            var localVarResponse = this.Client.Get<OathkeeperVersion>("/version", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetVersion", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get service version This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of OathkeeperVersion</returns>
        public async System.Threading.Tasks.Task<OathkeeperVersion> GetVersionAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Oathkeeper.Client.Client.ApiResponse<OathkeeperVersion> localVarResponse = await GetVersionWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get service version This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (OathkeeperVersion)</returns>
        public async System.Threading.Tasks.Task<Ory.Oathkeeper.Client.Client.ApiResponse<OathkeeperVersion>> GetVersionWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Ory.Oathkeeper.Client.Client.RequestOptions localVarRequestOptions = new Ory.Oathkeeper.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);



            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<OathkeeperVersion>("/version", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetVersion", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Lists cryptographic keys This endpoint returns cryptographic keys that are required to, for example, verify signatures of ID Tokens.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>OathkeeperJsonWebKeySet</returns>
        public OathkeeperJsonWebKeySet GetWellKnownJSONWebKeys()
        {
            Ory.Oathkeeper.Client.Client.ApiResponse<OathkeeperJsonWebKeySet> localVarResponse = GetWellKnownJSONWebKeysWithHttpInfo();
            return localVarResponse.Data;
        }

        /// <summary>
        /// Lists cryptographic keys This endpoint returns cryptographic keys that are required to, for example, verify signatures of ID Tokens.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of OathkeeperJsonWebKeySet</returns>
        public Ory.Oathkeeper.Client.Client.ApiResponse<OathkeeperJsonWebKeySet> GetWellKnownJSONWebKeysWithHttpInfo()
        {
            Ory.Oathkeeper.Client.Client.RequestOptions localVarRequestOptions = new Ory.Oathkeeper.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);



            // make the HTTP request
            var localVarResponse = this.Client.Get<OathkeeperJsonWebKeySet>("/.well-known/jwks.json", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetWellKnownJSONWebKeys", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Lists cryptographic keys This endpoint returns cryptographic keys that are required to, for example, verify signatures of ID Tokens.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of OathkeeperJsonWebKeySet</returns>
        public async System.Threading.Tasks.Task<OathkeeperJsonWebKeySet> GetWellKnownJSONWebKeysAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Oathkeeper.Client.Client.ApiResponse<OathkeeperJsonWebKeySet> localVarResponse = await GetWellKnownJSONWebKeysWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Lists cryptographic keys This endpoint returns cryptographic keys that are required to, for example, verify signatures of ID Tokens.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (OathkeeperJsonWebKeySet)</returns>
        public async System.Threading.Tasks.Task<Ory.Oathkeeper.Client.Client.ApiResponse<OathkeeperJsonWebKeySet>> GetWellKnownJSONWebKeysWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Ory.Oathkeeper.Client.Client.RequestOptions localVarRequestOptions = new Ory.Oathkeeper.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);



            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<OathkeeperJsonWebKeySet>("/.well-known/jwks.json", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetWellKnownJSONWebKeys", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Check alive status This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>OathkeeperHealthStatus</returns>
        public OathkeeperHealthStatus IsInstanceAlive()
        {
            Ory.Oathkeeper.Client.Client.ApiResponse<OathkeeperHealthStatus> localVarResponse = IsInstanceAliveWithHttpInfo();
            return localVarResponse.Data;
        }

        /// <summary>
        /// Check alive status This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of OathkeeperHealthStatus</returns>
        public Ory.Oathkeeper.Client.Client.ApiResponse<OathkeeperHealthStatus> IsInstanceAliveWithHttpInfo()
        {
            Ory.Oathkeeper.Client.Client.RequestOptions localVarRequestOptions = new Ory.Oathkeeper.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);



            // make the HTTP request
            var localVarResponse = this.Client.Get<OathkeeperHealthStatus>("/health/alive", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IsInstanceAlive", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Check alive status This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of OathkeeperHealthStatus</returns>
        public async System.Threading.Tasks.Task<OathkeeperHealthStatus> IsInstanceAliveAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Oathkeeper.Client.Client.ApiResponse<OathkeeperHealthStatus> localVarResponse = await IsInstanceAliveWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Check alive status This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (OathkeeperHealthStatus)</returns>
        public async System.Threading.Tasks.Task<Ory.Oathkeeper.Client.Client.ApiResponse<OathkeeperHealthStatus>> IsInstanceAliveWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Ory.Oathkeeper.Client.Client.RequestOptions localVarRequestOptions = new Ory.Oathkeeper.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);



            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<OathkeeperHealthStatus>("/health/alive", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IsInstanceAlive", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Check readiness status This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>OathkeeperHealthStatus</returns>
        public OathkeeperHealthStatus IsInstanceReady()
        {
            Ory.Oathkeeper.Client.Client.ApiResponse<OathkeeperHealthStatus> localVarResponse = IsInstanceReadyWithHttpInfo();
            return localVarResponse.Data;
        }

        /// <summary>
        /// Check readiness status This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <returns>ApiResponse of OathkeeperHealthStatus</returns>
        public Ory.Oathkeeper.Client.Client.ApiResponse<OathkeeperHealthStatus> IsInstanceReadyWithHttpInfo()
        {
            Ory.Oathkeeper.Client.Client.RequestOptions localVarRequestOptions = new Ory.Oathkeeper.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);



            // make the HTTP request
            var localVarResponse = this.Client.Get<OathkeeperHealthStatus>("/health/ready", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IsInstanceReady", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// Check readiness status This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of OathkeeperHealthStatus</returns>
        public async System.Threading.Tasks.Task<OathkeeperHealthStatus> IsInstanceReadyAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Oathkeeper.Client.Client.ApiResponse<OathkeeperHealthStatus> localVarResponse = await IsInstanceReadyWithHttpInfoAsync(cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Check readiness status This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the &#x60;X-Forwarded-Proto&#x60; header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (OathkeeperHealthStatus)</returns>
        public async System.Threading.Tasks.Task<Ory.Oathkeeper.Client.Client.ApiResponse<OathkeeperHealthStatus>> IsInstanceReadyWithHttpInfoAsync(System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Ory.Oathkeeper.Client.Client.RequestOptions localVarRequestOptions = new Ory.Oathkeeper.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);



            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<OathkeeperHealthStatus>("/health/ready", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("IsInstanceReady", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List all rules This method returns an array of all rules that are stored in the backend. This is useful if you want to get a full view of what rules you have currently in place.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">The maximum amount of rules returned. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <returns>List&lt;OathkeeperRule&gt;</returns>
        public List<OathkeeperRule> ListRules(long? limit = default(long?), long? offset = default(long?))
        {
            Ory.Oathkeeper.Client.Client.ApiResponse<List<OathkeeperRule>> localVarResponse = ListRulesWithHttpInfo(limit, offset);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List all rules This method returns an array of all rules that are stored in the backend. This is useful if you want to get a full view of what rules you have currently in place.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">The maximum amount of rules returned. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <returns>ApiResponse of List&lt;OathkeeperRule&gt;</returns>
        public Ory.Oathkeeper.Client.Client.ApiResponse<List<OathkeeperRule>> ListRulesWithHttpInfo(long? limit = default(long?), long? offset = default(long?))
        {
            Ory.Oathkeeper.Client.Client.RequestOptions localVarRequestOptions = new Ory.Oathkeeper.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Oathkeeper.Client.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Oathkeeper.Client.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }


            // make the HTTP request
            var localVarResponse = this.Client.Get<List<OathkeeperRule>>("/rules", localVarRequestOptions, this.Configuration);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListRules", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

        /// <summary>
        /// List all rules This method returns an array of all rules that are stored in the backend. This is useful if you want to get a full view of what rules you have currently in place.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">The maximum amount of rules returned. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;OathkeeperRule&gt;</returns>
        public async System.Threading.Tasks.Task<List<OathkeeperRule>> ListRulesAsync(long? limit = default(long?), long? offset = default(long?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Ory.Oathkeeper.Client.Client.ApiResponse<List<OathkeeperRule>> localVarResponse = await ListRulesWithHttpInfoAsync(limit, offset, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// List all rules This method returns an array of all rules that are stored in the backend. This is useful if you want to get a full view of what rules you have currently in place.
        /// </summary>
        /// <exception cref="Ory.Oathkeeper.Client.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="limit">The maximum amount of rules returned. (optional)</param>
        /// <param name="offset">The offset from where to start looking. (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;OathkeeperRule&gt;)</returns>
        public async System.Threading.Tasks.Task<Ory.Oathkeeper.Client.Client.ApiResponse<List<OathkeeperRule>>> ListRulesWithHttpInfoAsync(long? limit = default(long?), long? offset = default(long?), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Ory.Oathkeeper.Client.Client.RequestOptions localVarRequestOptions = new Ory.Oathkeeper.Client.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };


            var localVarContentType = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null) localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);

            var localVarAccept = Ory.Oathkeeper.Client.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null) localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);

            if (limit != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Oathkeeper.Client.Client.ClientUtils.ParameterToMultiMap("", "limit", limit));
            }
            if (offset != null)
            {
                localVarRequestOptions.QueryParameters.Add(Ory.Oathkeeper.Client.Client.ClientUtils.ParameterToMultiMap("", "offset", offset));
            }


            // make the HTTP request

            var localVarResponse = await this.AsynchronousClient.GetAsync<List<OathkeeperRule>>("/rules", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ListRules", localVarResponse);
                if (_exception != null) throw _exception;
            }

            return localVarResponse;
        }

    }
}
