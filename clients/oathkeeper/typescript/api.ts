/* tslint:disable */
/* eslint-disable */
/**
 * ORY Oathkeeper
 * ORY Oathkeeper is a reverse proxy that checks the HTTP Authorization for validity against a set of rules. This service uses Hydra to validate access tokens and policies.
 *
 * The version of the OpenAPI document: v0.0.0-alpha.49
 * Contact: hi@ory.am
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * A rule
 * @export
 * @interface CreateRuleCreated
 */
export interface CreateRuleCreated {
    /**
     * 
     * @type {SwaggerRule}
     * @memberof CreateRuleCreated
     */
    Payload?: SwaggerRule;
}
/**
 * The standard error format
 * @export
 * @interface CreateRuleForbidden
 */
export interface CreateRuleForbidden {
    /**
     * 
     * @type {CreateRuleForbiddenBody}
     * @memberof CreateRuleForbidden
     */
    Payload?: CreateRuleForbiddenBody;
}
/**
 * CreateRuleForbiddenBody CreateRuleForbiddenBody CreateRuleForbiddenBody CreateRuleForbiddenBody CreateRuleForbiddenBody CreateRuleForbiddenBody CreateRuleForbiddenBody create rule forbidden body
 * @export
 * @interface CreateRuleForbiddenBody
 */
export interface CreateRuleForbiddenBody {
    /**
     * code
     * @type {number}
     * @memberof CreateRuleForbiddenBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof CreateRuleForbiddenBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof CreateRuleForbiddenBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof CreateRuleForbiddenBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof CreateRuleForbiddenBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof CreateRuleForbiddenBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface CreateRuleInternalServerError
 */
export interface CreateRuleInternalServerError {
    /**
     * 
     * @type {CreateRuleInternalServerErrorBody}
     * @memberof CreateRuleInternalServerError
     */
    Payload?: CreateRuleInternalServerErrorBody;
}
/**
 * CreateRuleInternalServerErrorBody CreateRuleInternalServerErrorBody CreateRuleInternalServerErrorBody CreateRuleInternalServerErrorBody CreateRuleInternalServerErrorBody CreateRuleInternalServerErrorBody CreateRuleInternalServerErrorBody create rule internal server error body
 * @export
 * @interface CreateRuleInternalServerErrorBody
 */
export interface CreateRuleInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof CreateRuleInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof CreateRuleInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof CreateRuleInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof CreateRuleInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof CreateRuleInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof CreateRuleInternalServerErrorBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface CreateRuleUnauthorized
 */
export interface CreateRuleUnauthorized {
    /**
     * 
     * @type {CreateRuleUnauthorizedBody}
     * @memberof CreateRuleUnauthorized
     */
    Payload?: CreateRuleUnauthorizedBody;
}
/**
 * CreateRuleUnauthorizedBody CreateRuleUnauthorizedBody CreateRuleUnauthorizedBody CreateRuleUnauthorizedBody CreateRuleUnauthorizedBody CreateRuleUnauthorizedBody CreateRuleUnauthorizedBody create rule unauthorized body
 * @export
 * @interface CreateRuleUnauthorizedBody
 */
export interface CreateRuleUnauthorizedBody {
    /**
     * code
     * @type {number}
     * @memberof CreateRuleUnauthorizedBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof CreateRuleUnauthorizedBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof CreateRuleUnauthorizedBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof CreateRuleUnauthorizedBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof CreateRuleUnauthorizedBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof CreateRuleUnauthorizedBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface DecisionsForbidden
 */
export interface DecisionsForbidden {
    /**
     * 
     * @type {DecisionsForbiddenBody}
     * @memberof DecisionsForbidden
     */
    Payload?: DecisionsForbiddenBody;
}
/**
 * DecisionsForbiddenBody DecisionsForbiddenBody decisions forbidden body
 * @export
 * @interface DecisionsForbiddenBody
 */
export interface DecisionsForbiddenBody {
    /**
     * code
     * @type {number}
     * @memberof DecisionsForbiddenBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof DecisionsForbiddenBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof DecisionsForbiddenBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof DecisionsForbiddenBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof DecisionsForbiddenBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof DecisionsForbiddenBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface DecisionsInternalServerError
 */
export interface DecisionsInternalServerError {
    /**
     * 
     * @type {DecisionsInternalServerErrorBody}
     * @memberof DecisionsInternalServerError
     */
    Payload?: DecisionsInternalServerErrorBody;
}
/**
 * DecisionsInternalServerErrorBody DecisionsInternalServerErrorBody decisions internal server error body
 * @export
 * @interface DecisionsInternalServerErrorBody
 */
export interface DecisionsInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof DecisionsInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof DecisionsInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof DecisionsInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof DecisionsInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof DecisionsInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof DecisionsInternalServerErrorBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface DecisionsNotFound
 */
export interface DecisionsNotFound {
    /**
     * 
     * @type {DecisionsNotFoundBody}
     * @memberof DecisionsNotFound
     */
    Payload?: DecisionsNotFoundBody;
}
/**
 * DecisionsNotFoundBody DecisionsNotFoundBody decisions not found body
 * @export
 * @interface DecisionsNotFoundBody
 */
export interface DecisionsNotFoundBody {
    /**
     * code
     * @type {number}
     * @memberof DecisionsNotFoundBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof DecisionsNotFoundBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof DecisionsNotFoundBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof DecisionsNotFoundBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof DecisionsNotFoundBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof DecisionsNotFoundBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface DecisionsUnauthorized
 */
export interface DecisionsUnauthorized {
    /**
     * 
     * @type {DecisionsUnauthorizedBody}
     * @memberof DecisionsUnauthorized
     */
    Payload?: DecisionsUnauthorizedBody;
}
/**
 * DecisionsUnauthorizedBody DecisionsUnauthorizedBody decisions unauthorized body
 * @export
 * @interface DecisionsUnauthorizedBody
 */
export interface DecisionsUnauthorizedBody {
    /**
     * code
     * @type {number}
     * @memberof DecisionsUnauthorizedBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof DecisionsUnauthorizedBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof DecisionsUnauthorizedBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof DecisionsUnauthorizedBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof DecisionsUnauthorizedBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof DecisionsUnauthorizedBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface DeleteRuleForbidden
 */
export interface DeleteRuleForbidden {
    /**
     * 
     * @type {DeleteRuleForbiddenBody}
     * @memberof DeleteRuleForbidden
     */
    Payload?: DeleteRuleForbiddenBody;
}
/**
 * DeleteRuleForbiddenBody DeleteRuleForbiddenBody DeleteRuleForbiddenBody DeleteRuleForbiddenBody DeleteRuleForbiddenBody DeleteRuleForbiddenBody DeleteRuleForbiddenBody delete rule forbidden body
 * @export
 * @interface DeleteRuleForbiddenBody
 */
export interface DeleteRuleForbiddenBody {
    /**
     * code
     * @type {number}
     * @memberof DeleteRuleForbiddenBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof DeleteRuleForbiddenBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof DeleteRuleForbiddenBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof DeleteRuleForbiddenBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof DeleteRuleForbiddenBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof DeleteRuleForbiddenBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface DeleteRuleInternalServerError
 */
export interface DeleteRuleInternalServerError {
    /**
     * 
     * @type {DeleteRuleInternalServerErrorBody}
     * @memberof DeleteRuleInternalServerError
     */
    Payload?: DeleteRuleInternalServerErrorBody;
}
/**
 * DeleteRuleInternalServerErrorBody DeleteRuleInternalServerErrorBody DeleteRuleInternalServerErrorBody DeleteRuleInternalServerErrorBody DeleteRuleInternalServerErrorBody DeleteRuleInternalServerErrorBody DeleteRuleInternalServerErrorBody delete rule internal server error body
 * @export
 * @interface DeleteRuleInternalServerErrorBody
 */
export interface DeleteRuleInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof DeleteRuleInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof DeleteRuleInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof DeleteRuleInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof DeleteRuleInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof DeleteRuleInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof DeleteRuleInternalServerErrorBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface DeleteRuleNotFound
 */
export interface DeleteRuleNotFound {
    /**
     * 
     * @type {DeleteRuleNotFoundBody}
     * @memberof DeleteRuleNotFound
     */
    Payload?: DeleteRuleNotFoundBody;
}
/**
 * DeleteRuleNotFoundBody DeleteRuleNotFoundBody DeleteRuleNotFoundBody DeleteRuleNotFoundBody DeleteRuleNotFoundBody DeleteRuleNotFoundBody DeleteRuleNotFoundBody delete rule not found body
 * @export
 * @interface DeleteRuleNotFoundBody
 */
export interface DeleteRuleNotFoundBody {
    /**
     * code
     * @type {number}
     * @memberof DeleteRuleNotFoundBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof DeleteRuleNotFoundBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof DeleteRuleNotFoundBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof DeleteRuleNotFoundBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof DeleteRuleNotFoundBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof DeleteRuleNotFoundBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface DeleteRuleUnauthorized
 */
export interface DeleteRuleUnauthorized {
    /**
     * 
     * @type {DeleteRuleUnauthorizedBody}
     * @memberof DeleteRuleUnauthorized
     */
    Payload?: DeleteRuleUnauthorizedBody;
}
/**
 * DeleteRuleUnauthorizedBody DeleteRuleUnauthorizedBody DeleteRuleUnauthorizedBody DeleteRuleUnauthorizedBody DeleteRuleUnauthorizedBody DeleteRuleUnauthorizedBody DeleteRuleUnauthorizedBody delete rule unauthorized body
 * @export
 * @interface DeleteRuleUnauthorizedBody
 */
export interface DeleteRuleUnauthorizedBody {
    /**
     * code
     * @type {number}
     * @memberof DeleteRuleUnauthorizedBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof DeleteRuleUnauthorizedBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof DeleteRuleUnauthorizedBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof DeleteRuleUnauthorizedBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof DeleteRuleUnauthorizedBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof DeleteRuleUnauthorizedBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface GetRuleForbidden
 */
export interface GetRuleForbidden {
    /**
     * 
     * @type {GetRuleForbiddenBody}
     * @memberof GetRuleForbidden
     */
    Payload?: GetRuleForbiddenBody;
}
/**
 * GetRuleForbiddenBody GetRuleForbiddenBody GetRuleForbiddenBody GetRuleForbiddenBody GetRuleForbiddenBody GetRuleForbiddenBody GetRuleForbiddenBody get rule forbidden body
 * @export
 * @interface GetRuleForbiddenBody
 */
export interface GetRuleForbiddenBody {
    /**
     * code
     * @type {number}
     * @memberof GetRuleForbiddenBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof GetRuleForbiddenBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof GetRuleForbiddenBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof GetRuleForbiddenBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof GetRuleForbiddenBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof GetRuleForbiddenBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface GetRuleInternalServerError
 */
export interface GetRuleInternalServerError {
    /**
     * 
     * @type {GetRuleInternalServerErrorBody}
     * @memberof GetRuleInternalServerError
     */
    Payload?: GetRuleInternalServerErrorBody;
}
/**
 * GetRuleInternalServerErrorBody GetRuleInternalServerErrorBody get rule internal server error body
 * @export
 * @interface GetRuleInternalServerErrorBody
 */
export interface GetRuleInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof GetRuleInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof GetRuleInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof GetRuleInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof GetRuleInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof GetRuleInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof GetRuleInternalServerErrorBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface GetRuleNotFound
 */
export interface GetRuleNotFound {
    /**
     * 
     * @type {GetRuleNotFoundBody}
     * @memberof GetRuleNotFound
     */
    Payload?: GetRuleNotFoundBody;
}
/**
 * GetRuleNotFoundBody GetRuleNotFoundBody get rule not found body
 * @export
 * @interface GetRuleNotFoundBody
 */
export interface GetRuleNotFoundBody {
    /**
     * code
     * @type {number}
     * @memberof GetRuleNotFoundBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof GetRuleNotFoundBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof GetRuleNotFoundBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof GetRuleNotFoundBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof GetRuleNotFoundBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof GetRuleNotFoundBody
     */
    status?: string;
}
/**
 * A rule
 * @export
 * @interface GetRuleOK
 */
export interface GetRuleOK {
    /**
     * 
     * @type {SwaggerRule}
     * @memberof GetRuleOK
     */
    Payload?: SwaggerRule;
}
/**
 * The standard error format
 * @export
 * @interface GetRuleUnauthorized
 */
export interface GetRuleUnauthorized {
    /**
     * 
     * @type {GetRuleUnauthorizedBody}
     * @memberof GetRuleUnauthorized
     */
    Payload?: GetRuleUnauthorizedBody;
}
/**
 * GetRuleUnauthorizedBody GetRuleUnauthorizedBody GetRuleUnauthorizedBody GetRuleUnauthorizedBody GetRuleUnauthorizedBody GetRuleUnauthorizedBody GetRuleUnauthorizedBody get rule unauthorized body
 * @export
 * @interface GetRuleUnauthorizedBody
 */
export interface GetRuleUnauthorizedBody {
    /**
     * code
     * @type {number}
     * @memberof GetRuleUnauthorizedBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof GetRuleUnauthorizedBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof GetRuleUnauthorizedBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof GetRuleUnauthorizedBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof GetRuleUnauthorizedBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof GetRuleUnauthorizedBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface GetWellKnownForbidden
 */
export interface GetWellKnownForbidden {
    /**
     * 
     * @type {GetWellKnownForbiddenBody}
     * @memberof GetWellKnownForbidden
     */
    Payload?: GetWellKnownForbiddenBody;
}
/**
 * GetWellKnownForbiddenBody GetWellKnownForbiddenBody GetWellKnownForbiddenBody GetWellKnownForbiddenBody GetWellKnownForbiddenBody GetWellKnownForbiddenBody GetWellKnownForbiddenBody get well known forbidden body
 * @export
 * @interface GetWellKnownForbiddenBody
 */
export interface GetWellKnownForbiddenBody {
    /**
     * code
     * @type {number}
     * @memberof GetWellKnownForbiddenBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof GetWellKnownForbiddenBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof GetWellKnownForbiddenBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof GetWellKnownForbiddenBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof GetWellKnownForbiddenBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof GetWellKnownForbiddenBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface GetWellKnownJSONWebKeysInternalServerError
 */
export interface GetWellKnownJSONWebKeysInternalServerError {
    /**
     * 
     * @type {GetWellKnownJSONWebKeysInternalServerErrorBody}
     * @memberof GetWellKnownJSONWebKeysInternalServerError
     */
    Payload?: GetWellKnownJSONWebKeysInternalServerErrorBody;
}
/**
 * GetWellKnownJSONWebKeysInternalServerErrorBody GetWellKnownJSONWebKeysInternalServerErrorBody get well known JSON web keys internal server error body
 * @export
 * @interface GetWellKnownJSONWebKeysInternalServerErrorBody
 */
export interface GetWellKnownJSONWebKeysInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof GetWellKnownJSONWebKeysInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof GetWellKnownJSONWebKeysInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof GetWellKnownJSONWebKeysInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof GetWellKnownJSONWebKeysInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof GetWellKnownJSONWebKeysInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof GetWellKnownJSONWebKeysInternalServerErrorBody
     */
    status?: string;
}
/**
 * jsonWebKeySet
 * @export
 * @interface GetWellKnownJSONWebKeysOK
 */
export interface GetWellKnownJSONWebKeysOK {
    /**
     * 
     * @type {SwaggerJSONWebKeySet}
     * @memberof GetWellKnownJSONWebKeysOK
     */
    Payload?: SwaggerJSONWebKeySet;
}
/**
 * jsonWebKeySet
 * @export
 * @interface GetWellKnownOK
 */
export interface GetWellKnownOK {
    /**
     * 
     * @type {SwaggerJSONWebKeySet}
     * @memberof GetWellKnownOK
     */
    Payload?: SwaggerJSONWebKeySet;
}
/**
 * The standard error format
 * @export
 * @interface GetWellKnownUnauthorized
 */
export interface GetWellKnownUnauthorized {
    /**
     * 
     * @type {GetWellKnownUnauthorizedBody}
     * @memberof GetWellKnownUnauthorized
     */
    Payload?: GetWellKnownUnauthorizedBody;
}
/**
 * GetWellKnownUnauthorizedBody GetWellKnownUnauthorizedBody GetWellKnownUnauthorizedBody GetWellKnownUnauthorizedBody GetWellKnownUnauthorizedBody GetWellKnownUnauthorizedBody GetWellKnownUnauthorizedBody get well known unauthorized body
 * @export
 * @interface GetWellKnownUnauthorizedBody
 */
export interface GetWellKnownUnauthorizedBody {
    /**
     * code
     * @type {number}
     * @memberof GetWellKnownUnauthorizedBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof GetWellKnownUnauthorizedBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof GetWellKnownUnauthorizedBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof GetWellKnownUnauthorizedBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof GetWellKnownUnauthorizedBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof GetWellKnownUnauthorizedBody
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface HealthNotReadyStatus
 */
export interface HealthNotReadyStatus {
    /**
     * Errors contains a list of errors that caused the not ready status.
     * @type {{ [key: string]: string; }}
     * @memberof HealthNotReadyStatus
     */
    errors?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface HealthStatus
 */
export interface HealthStatus {
    /**
     * Status always contains \"ok\".
     * @type {string}
     * @memberof HealthStatus
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse500
 */
export interface InlineResponse500 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse500
     */
    code?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof InlineResponse500
     */
    details?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse500
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse500
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse500
     */
    request?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse500
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface IsInstanceAliveInternalServerError
 */
export interface IsInstanceAliveInternalServerError {
    /**
     * 
     * @type {IsInstanceAliveInternalServerErrorBody}
     * @memberof IsInstanceAliveInternalServerError
     */
    Payload?: IsInstanceAliveInternalServerErrorBody;
}
/**
 * IsInstanceAliveInternalServerErrorBody IsInstanceAliveInternalServerErrorBody is instance alive internal server error body
 * @export
 * @interface IsInstanceAliveInternalServerErrorBody
 */
export interface IsInstanceAliveInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof IsInstanceAliveInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof IsInstanceAliveInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof IsInstanceAliveInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof IsInstanceAliveInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof IsInstanceAliveInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof IsInstanceAliveInternalServerErrorBody
     */
    status?: string;
}
/**
 * healthStatus
 * @export
 * @interface IsInstanceAliveOK
 */
export interface IsInstanceAliveOK {
    /**
     * 
     * @type {SwaggerHealthStatus}
     * @memberof IsInstanceAliveOK
     */
    Payload?: SwaggerHealthStatus;
}
/**
 * 
 * @export
 * @interface JsonWebKey
 */
export interface JsonWebKey {
    /**
     * The \"alg\" (algorithm) parameter identifies the algorithm intended for use with the key.  The values used should either be registered in the IANA \"JSON Web Signature and Encryption Algorithms\" registry established by [JWA] or be a value that contains a Collision- Resistant Name.
     * @type {string}
     * @memberof JsonWebKey
     */
    alg?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonWebKey
     */
    crv?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonWebKey
     */
    d?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonWebKey
     */
    dp?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonWebKey
     */
    dq?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonWebKey
     */
    e?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonWebKey
     */
    k?: string;
    /**
     * The \"kid\" (key ID) parameter is used to match a specific key.  This is used, for instance, to choose among a set of keys within a JWK Set during key rollover.  The structure of the \"kid\" value is unspecified.  When \"kid\" values are used within a JWK Set, different keys within the JWK Set SHOULD use distinct \"kid\" values.  (One example in which different keys might use the same \"kid\" value is if they have different \"kty\" (key type) values but are considered to be equivalent alternatives by the application using them.)  The \"kid\" value is a case-sensitive string.
     * @type {string}
     * @memberof JsonWebKey
     */
    kid?: string;
    /**
     * The \"kty\" (key type) parameter identifies the cryptographic algorithm family used with the key, such as \"RSA\" or \"EC\". \"kty\" values should either be registered in the IANA \"JSON Web Key Types\" registry established by [JWA] or be a value that contains a Collision- Resistant Name.  The \"kty\" value is a case-sensitive string.
     * @type {string}
     * @memberof JsonWebKey
     */
    kty?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonWebKey
     */
    n?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonWebKey
     */
    p?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonWebKey
     */
    q?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonWebKey
     */
    qi?: string;
    /**
     * The \"use\" (public key use) parameter identifies the intended use of the public key. The \"use\" parameter is employed to indicate whether a public key is used for encrypting data or verifying the signature on data. Values are commonly \"sig\" (signature) or \"enc\" (encryption).
     * @type {string}
     * @memberof JsonWebKey
     */
    use?: string;
    /**
     * 
     * @type {string}
     * @memberof JsonWebKey
     */
    x?: string;
    /**
     * The \"x5c\" (X.509 certificate chain) parameter contains a chain of one or more PKIX certificates [RFC5280].  The certificate chain is represented as a JSON array of certificate value strings.  Each string in the array is a base64-encoded (Section 4 of [RFC4648] -- not base64url-encoded) DER [ITU.X690.1994] PKIX certificate value. The PKIX certificate containing the key value MUST be the first certificate.
     * @type {Array<string>}
     * @memberof JsonWebKey
     */
    x5c?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof JsonWebKey
     */
    y?: string;
}
/**
 * 
 * @export
 * @interface JsonWebKeySet
 */
export interface JsonWebKeySet {
    /**
     * The value of the \"keys\" parameter is an array of JWK values.  By default, the order of the JWK values within the array does not imply an order of preference among them, although applications of JWK Sets can choose to assign a meaning to the order for their purposes, if desired.
     * @type {Array<JsonWebKey>}
     * @memberof JsonWebKeySet
     */
    keys?: Array<JsonWebKey>;
}
/**
 * The standard error format
 * @export
 * @interface JudgeForbidden
 */
export interface JudgeForbidden {
    /**
     * 
     * @type {JudgeForbiddenBody}
     * @memberof JudgeForbidden
     */
    Payload?: JudgeForbiddenBody;
}
/**
 * JudgeForbiddenBody JudgeForbiddenBody JudgeForbiddenBody judge forbidden body
 * @export
 * @interface JudgeForbiddenBody
 */
export interface JudgeForbiddenBody {
    /**
     * code
     * @type {number}
     * @memberof JudgeForbiddenBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof JudgeForbiddenBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof JudgeForbiddenBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof JudgeForbiddenBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof JudgeForbiddenBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof JudgeForbiddenBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface JudgeInternalServerError
 */
export interface JudgeInternalServerError {
    /**
     * 
     * @type {JudgeInternalServerErrorBody}
     * @memberof JudgeInternalServerError
     */
    Payload?: JudgeInternalServerErrorBody;
}
/**
 * JudgeInternalServerErrorBody JudgeInternalServerErrorBody JudgeInternalServerErrorBody judge internal server error body
 * @export
 * @interface JudgeInternalServerErrorBody
 */
export interface JudgeInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof JudgeInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof JudgeInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof JudgeInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof JudgeInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof JudgeInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof JudgeInternalServerErrorBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface JudgeNotFound
 */
export interface JudgeNotFound {
    /**
     * 
     * @type {JudgeNotFoundBody}
     * @memberof JudgeNotFound
     */
    Payload?: JudgeNotFoundBody;
}
/**
 * JudgeNotFoundBody JudgeNotFoundBody JudgeNotFoundBody judge not found body
 * @export
 * @interface JudgeNotFoundBody
 */
export interface JudgeNotFoundBody {
    /**
     * code
     * @type {number}
     * @memberof JudgeNotFoundBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof JudgeNotFoundBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof JudgeNotFoundBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof JudgeNotFoundBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof JudgeNotFoundBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof JudgeNotFoundBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface JudgeUnauthorized
 */
export interface JudgeUnauthorized {
    /**
     * 
     * @type {JudgeUnauthorizedBody}
     * @memberof JudgeUnauthorized
     */
    Payload?: JudgeUnauthorizedBody;
}
/**
 * JudgeUnauthorizedBody JudgeUnauthorizedBody JudgeUnauthorizedBody judge unauthorized body
 * @export
 * @interface JudgeUnauthorizedBody
 */
export interface JudgeUnauthorizedBody {
    /**
     * code
     * @type {number}
     * @memberof JudgeUnauthorizedBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof JudgeUnauthorizedBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof JudgeUnauthorizedBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof JudgeUnauthorizedBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof JudgeUnauthorizedBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof JudgeUnauthorizedBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface ListRulesForbidden
 */
export interface ListRulesForbidden {
    /**
     * 
     * @type {ListRulesForbiddenBody}
     * @memberof ListRulesForbidden
     */
    Payload?: ListRulesForbiddenBody;
}
/**
 * ListRulesForbiddenBody ListRulesForbiddenBody ListRulesForbiddenBody ListRulesForbiddenBody ListRulesForbiddenBody ListRulesForbiddenBody ListRulesForbiddenBody list rules forbidden body
 * @export
 * @interface ListRulesForbiddenBody
 */
export interface ListRulesForbiddenBody {
    /**
     * code
     * @type {number}
     * @memberof ListRulesForbiddenBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof ListRulesForbiddenBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof ListRulesForbiddenBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof ListRulesForbiddenBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof ListRulesForbiddenBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof ListRulesForbiddenBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface ListRulesInternalServerError
 */
export interface ListRulesInternalServerError {
    /**
     * 
     * @type {ListRulesInternalServerErrorBody}
     * @memberof ListRulesInternalServerError
     */
    Payload?: ListRulesInternalServerErrorBody;
}
/**
 * ListRulesInternalServerErrorBody ListRulesInternalServerErrorBody list rules internal server error body
 * @export
 * @interface ListRulesInternalServerErrorBody
 */
export interface ListRulesInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof ListRulesInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof ListRulesInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof ListRulesInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof ListRulesInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof ListRulesInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof ListRulesInternalServerErrorBody
     */
    status?: string;
}
/**
 * A list of rules
 * @export
 * @interface ListRulesOK
 */
export interface ListRulesOK {
    /**
     * payload
     * @type {Array<SwaggerRule>}
     * @memberof ListRulesOK
     */
    Payload?: Array<SwaggerRule>;
}
/**
 * The standard error format
 * @export
 * @interface ListRulesUnauthorized
 */
export interface ListRulesUnauthorized {
    /**
     * 
     * @type {ListRulesUnauthorizedBody}
     * @memberof ListRulesUnauthorized
     */
    Payload?: ListRulesUnauthorizedBody;
}
/**
 * ListRulesUnauthorizedBody ListRulesUnauthorizedBody ListRulesUnauthorizedBody ListRulesUnauthorizedBody ListRulesUnauthorizedBody ListRulesUnauthorizedBody ListRulesUnauthorizedBody list rules unauthorized body
 * @export
 * @interface ListRulesUnauthorizedBody
 */
export interface ListRulesUnauthorizedBody {
    /**
     * code
     * @type {number}
     * @memberof ListRulesUnauthorizedBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof ListRulesUnauthorizedBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof ListRulesUnauthorizedBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof ListRulesUnauthorizedBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof ListRulesUnauthorizedBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof ListRulesUnauthorizedBody
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     * Authenticators is a list of authentication handlers that will try and authenticate the provided credentials. Authenticators are checked iteratively from index 0 to n and if the first authenticator to return a positive result will be the one used.  If you want the rule to first check a specific authenticator  before \"falling back\" to others, have that authenticator as the first item in the array.
     * @type {Array<RuleHandler>}
     * @memberof Rule
     */
    authenticators?: Array<RuleHandler>;
    /**
     * 
     * @type {RuleHandler}
     * @memberof Rule
     */
    authorizer?: RuleHandler;
    /**
     * Description is a human readable description of this rule.
     * @type {string}
     * @memberof Rule
     */
    description?: string;
    /**
     * ID is the unique id of the rule. It can be at most 190 characters long, but the layout of the ID is up to you. You will need this ID later on to update or delete the rule.
     * @type {string}
     * @memberof Rule
     */
    id?: string;
    /**
     * 
     * @type {RuleMatch}
     * @memberof Rule
     */
    match?: RuleMatch;
    /**
     * Mutators is a list of mutation handlers that transform the HTTP request. A common use case is generating a new set of credentials (e.g. JWT) which then will be forwarded to the upstream server.  Mutations are performed iteratively from index 0 to n and should all succeed in order for the HTTP request to be forwarded.
     * @type {Array<RuleHandler>}
     * @memberof Rule
     */
    mutators?: Array<RuleHandler>;
    /**
     * 
     * @type {Upstream}
     * @memberof Rule
     */
    upstream?: Upstream;
}
/**
 * 
 * @export
 * @interface RuleHandler
 */
export interface RuleHandler {
    /**
     * Config contains the configuration for the handler. Please read the user guide for a complete list of each handler\'s available settings.
     * @type {object}
     * @memberof RuleHandler
     */
    config?: object;
    /**
     * Handler identifies the implementation which will be used to handle this specific request. Please read the user guide for a complete list of available handlers.
     * @type {string}
     * @memberof RuleHandler
     */
    handler?: string;
}
/**
 * 
 * @export
 * @interface RuleMatch
 */
export interface RuleMatch {
    /**
     * An array of HTTP methods (e.g. GET, POST, PUT, DELETE, ...). When ORY Oathkeeper searches for rules to decide what to do with an incoming request to the proxy server, it compares the HTTP method of the incoming request with the HTTP methods of each rules. If a match is found, the rule is considered a partial match. If the matchesUrl field is satisfied as well, the rule is considered a full match.
     * @type {Array<string>}
     * @memberof RuleMatch
     */
    methods?: Array<string>;
    /**
     * This field represents the URL pattern this rule matches. When ORY Oathkeeper searches for rules to decide what to do with an incoming request to the proxy server, it compares the full request URL (e.g. https://mydomain.com/api/resource) without query parameters of the incoming request with this field. If a match is found, the rule is considered a partial match. If the matchesMethods field is satisfied as well, the rule is considered a full match.  You can use regular expressions in this field to match more than one url. Regular expressions are encapsulated in brackets < and >. The following example matches all paths of the domain `mydomain.com`: `https://mydomain.com/<.*>`.
     * @type {string}
     * @memberof RuleMatch
     */
    url?: string;
}
/**
 * SwaggerCreateRuleParameters SwaggerCreateRuleParameters SwaggerCreateRuleParameters SwaggerCreateRuleParameters SwaggerCreateRuleParameters swagger create rule parameters
 * @export
 * @interface SwaggerCreateRuleParameters
 */
export interface SwaggerCreateRuleParameters {
    /**
     * 
     * @type {SwaggerRule}
     * @memberof SwaggerCreateRuleParameters
     */
    Body?: SwaggerRule;
}
/**
 * SwaggerGetRuleParameters swagger get rule parameters
 * @export
 * @interface SwaggerGetRuleParameters
 */
export interface SwaggerGetRuleParameters {
    /**
     * in: path
     * @type {string}
     * @memberof SwaggerGetRuleParameters
     */
    id: string;
}
/**
 * SwaggerHealthStatus swagger health status
 * @export
 * @interface SwaggerHealthStatus
 */
export interface SwaggerHealthStatus {
    /**
     * Status always contains \"ok\".
     * @type {string}
     * @memberof SwaggerHealthStatus
     */
    status?: string;
}
/**
 * SwaggerJSONWebKey swagger JSON web key
 * @export
 * @interface SwaggerJSONWebKey
 */
export interface SwaggerJSONWebKey {
    /**
     * The \"alg\" (algorithm) parameter identifies the algorithm intended for use with the key.  The values used should either be registered in the IANA \"JSON Web Signature and Encryption Algorithms\" registry established by [JWA] or be a value that contains a Collision- Resistant Name.
     * @type {string}
     * @memberof SwaggerJSONWebKey
     */
    alg?: string;
    /**
     * crv
     * @type {string}
     * @memberof SwaggerJSONWebKey
     */
    crv?: string;
    /**
     * d
     * @type {string}
     * @memberof SwaggerJSONWebKey
     */
    d?: string;
    /**
     * dp
     * @type {string}
     * @memberof SwaggerJSONWebKey
     */
    dp?: string;
    /**
     * dq
     * @type {string}
     * @memberof SwaggerJSONWebKey
     */
    dq?: string;
    /**
     * e
     * @type {string}
     * @memberof SwaggerJSONWebKey
     */
    e?: string;
    /**
     * k
     * @type {string}
     * @memberof SwaggerJSONWebKey
     */
    k?: string;
    /**
     * The \"kid\" (key ID) parameter is used to match a specific key.  This is used, for instance, to choose among a set of keys within a JWK Set during key rollover.  The structure of the \"kid\" value is unspecified.  When \"kid\" values are used within a JWK Set, different keys within the JWK Set SHOULD use distinct \"kid\" values.  (One example in which different keys might use the same \"kid\" value is if they have different \"kty\" (key type) values but are considered to be equivalent alternatives by the application using them.)  The \"kid\" value is a case-sensitive string.
     * @type {string}
     * @memberof SwaggerJSONWebKey
     */
    kid?: string;
    /**
     * The \"kty\" (key type) parameter identifies the cryptographic algorithm family used with the key, such as \"RSA\" or \"EC\". \"kty\" values should either be registered in the IANA \"JSON Web Key Types\" registry established by [JWA] or be a value that contains a Collision- Resistant Name.  The \"kty\" value is a case-sensitive string.
     * @type {string}
     * @memberof SwaggerJSONWebKey
     */
    kty?: string;
    /**
     * n
     * @type {string}
     * @memberof SwaggerJSONWebKey
     */
    n?: string;
    /**
     * p
     * @type {string}
     * @memberof SwaggerJSONWebKey
     */
    p?: string;
    /**
     * q
     * @type {string}
     * @memberof SwaggerJSONWebKey
     */
    q?: string;
    /**
     * qi
     * @type {string}
     * @memberof SwaggerJSONWebKey
     */
    qi?: string;
    /**
     * The \"use\" (public key use) parameter identifies the intended use of the public key. The \"use\" parameter is employed to indicate whether a public key is used for encrypting data or verifying the signature on data. Values are commonly \"sig\" (signature) or \"enc\" (encryption).
     * @type {string}
     * @memberof SwaggerJSONWebKey
     */
    use?: string;
    /**
     * x
     * @type {string}
     * @memberof SwaggerJSONWebKey
     */
    x?: string;
    /**
     * The \"x5c\" (X.509 certificate chain) parameter contains a chain of one or more PKIX certificates [RFC5280].  The certificate chain is represented as a JSON array of certificate value strings.  Each string in the array is a base64-encoded (Section 4 of [RFC4648] -- not base64url-encoded) DER [ITU.X690.1994] PKIX certificate value. The PKIX certificate containing the key value MUST be the first certificate.
     * @type {Array<string>}
     * @memberof SwaggerJSONWebKey
     */
    x5c?: Array<string>;
    /**
     * y
     * @type {string}
     * @memberof SwaggerJSONWebKey
     */
    y?: string;
}
/**
 * SwaggerJSONWebKeySet swagger JSON web key set
 * @export
 * @interface SwaggerJSONWebKeySet
 */
export interface SwaggerJSONWebKeySet {
    /**
     * The value of the \"keys\" parameter is an array of JWK values.  By default, the order of the JWK values within the array does not imply an order of preference among them, although applications of JWK Sets can choose to assign a meaning to the order for their purposes, if desired.
     * @type {Array<SwaggerJSONWebKey>}
     * @memberof SwaggerJSONWebKeySet
     */
    keys?: Array<SwaggerJSONWebKey>;
}
/**
 * SwaggerListRulesParameters swagger list rules parameters
 * @export
 * @interface SwaggerListRulesParameters
 */
export interface SwaggerListRulesParameters {
    /**
     * The maximum amount of rules returned. in: query
     * @type {number}
     * @memberof SwaggerListRulesParameters
     */
    limit?: number;
    /**
     * The offset from where to start looking. in: query
     * @type {number}
     * @memberof SwaggerListRulesParameters
     */
    offset?: number;
}
/**
 * SwaggerNotReadyStatus swagger not ready status
 * @export
 * @interface SwaggerNotReadyStatus
 */
export interface SwaggerNotReadyStatus {
    /**
     * Errors contains a list of errors that caused the not ready status.
     * @type {{ [key: string]: string; }}
     * @memberof SwaggerNotReadyStatus
     */
    errors?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface SwaggerRule
 */
export interface SwaggerRule {
    /**
     * Authenticators is a list of authentication handlers that will try and authenticate the provided credentials. Authenticators are checked iteratively from index 0 to n and if the first authenticator to return a positive result will be the one used.  If you want the rule to first check a specific authenticator  before \"falling back\" to others, have that authenticator as the first item in the array.
     * @type {Array<SwaggerRuleHandler>}
     * @memberof SwaggerRule
     */
    authenticators?: Array<SwaggerRuleHandler>;
    /**
     * 
     * @type {SwaggerRuleHandler}
     * @memberof SwaggerRule
     */
    authorizer?: SwaggerRuleHandler;
    /**
     * Description is a human readable description of this rule.
     * @type {string}
     * @memberof SwaggerRule
     */
    description?: string;
    /**
     * ID is the unique id of the rule. It can be at most 190 characters long, but the layout of the ID is up to you. You will need this ID later on to update or delete the rule.
     * @type {string}
     * @memberof SwaggerRule
     */
    id?: string;
    /**
     * 
     * @type {SwaggerRuleMatch}
     * @memberof SwaggerRule
     */
    match?: SwaggerRuleMatch;
    /**
     * Mutators is a list of mutation handlers that transform the HTTP request. A common use case is generating a new set of credentials (e.g. JWT) which then will be forwarded to the upstream server.  Mutations are performed iteratively from index 0 to n and should all succeed in order for the HTTP request to be forwarded.
     * @type {Array<SwaggerRuleHandler>}
     * @memberof SwaggerRule
     */
    mutators?: Array<SwaggerRuleHandler>;
    /**
     * 
     * @type {Upstream}
     * @memberof SwaggerRule
     */
    upstream?: Upstream;
}
/**
 * SwaggerRuleHandler swagger rule handler
 * @export
 * @interface SwaggerRuleHandler
 */
export interface SwaggerRuleHandler {
    /**
     * Config contains the configuration for the handler. Please read the user guide for a complete list of each handler\'s available settings.
     * @type {object}
     * @memberof SwaggerRuleHandler
     */
    config?: object;
    /**
     * Handler identifies the implementation which will be used to handle this specific request. Please read the user guide for a complete list of available handlers.
     * @type {string}
     * @memberof SwaggerRuleHandler
     */
    handler?: string;
}
/**
 * SwaggerRuleMatch swagger rule match
 * @export
 * @interface SwaggerRuleMatch
 */
export interface SwaggerRuleMatch {
    /**
     * An array of HTTP methods (e.g. GET, POST, PUT, DELETE, ...). When ORY Oathkeeper searches for rules to decide what to do with an incoming request to the proxy server, it compares the HTTP method of the incoming request with the HTTP methods of each rules. If a match is found, the rule is considered a partial match. If the matchesUrl field is satisfied as well, the rule is considered a full match.
     * @type {Array<string>}
     * @memberof SwaggerRuleMatch
     */
    methods?: Array<string>;
    /**
     * This field represents the URL pattern this rule matches. When ORY Oathkeeper searches for rules to decide what to do with an incoming request to the proxy server, it compares the full request URL (e.g. https://mydomain.com/api/resource) without query parameters of the incoming request with this field. If a match is found, the rule is considered a partial match. If the matchesMethods field is satisfied as well, the rule is considered a full match.  You can use regular expressions in this field to match more than one url. Regular expressions are encapsulated in brackets < and >. The following example matches all paths of the domain `mydomain.com`: `https://mydomain.com/<.*>`.
     * @type {string}
     * @memberof SwaggerRuleMatch
     */
    url?: string;
}
/**
 * SwaggerRuleResponse A rule
 * @export
 * @interface SwaggerRuleResponse
 */
export interface SwaggerRuleResponse {
    /**
     * 
     * @type {SwaggerRule}
     * @memberof SwaggerRuleResponse
     */
    Body?: SwaggerRule;
}
/**
 * SwaggerRulesResponse A list of rules
 * @export
 * @interface SwaggerRulesResponse
 */
export interface SwaggerRulesResponse {
    /**
     * in: body type: array
     * @type {Array<SwaggerRule>}
     * @memberof SwaggerRulesResponse
     */
    Body?: Array<SwaggerRule>;
}
/**
 * SwaggerUpdateRuleParameters SwaggerUpdateRuleParameters SwaggerUpdateRuleParameters SwaggerUpdateRuleParameters SwaggerUpdateRuleParameters swagger update rule parameters
 * @export
 * @interface SwaggerUpdateRuleParameters
 */
export interface SwaggerUpdateRuleParameters {
    /**
     * 
     * @type {SwaggerRule}
     * @memberof SwaggerUpdateRuleParameters
     */
    Body?: SwaggerRule;
    /**
     * in: path
     * @type {string}
     * @memberof SwaggerUpdateRuleParameters
     */
    id: string;
}
/**
 * SwaggerVersion swagger version
 * @export
 * @interface SwaggerVersion
 */
export interface SwaggerVersion {
    /**
     * Version is the service\'s version.
     * @type {string}
     * @memberof SwaggerVersion
     */
    version?: string;
}
/**
 * The standard error format
 * @export
 * @interface UpdateRuleForbidden
 */
export interface UpdateRuleForbidden {
    /**
     * 
     * @type {UpdateRuleForbiddenBody}
     * @memberof UpdateRuleForbidden
     */
    Payload?: UpdateRuleForbiddenBody;
}
/**
 * UpdateRuleForbiddenBody UpdateRuleForbiddenBody UpdateRuleForbiddenBody UpdateRuleForbiddenBody UpdateRuleForbiddenBody UpdateRuleForbiddenBody UpdateRuleForbiddenBody update rule forbidden body
 * @export
 * @interface UpdateRuleForbiddenBody
 */
export interface UpdateRuleForbiddenBody {
    /**
     * code
     * @type {number}
     * @memberof UpdateRuleForbiddenBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof UpdateRuleForbiddenBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof UpdateRuleForbiddenBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof UpdateRuleForbiddenBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof UpdateRuleForbiddenBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof UpdateRuleForbiddenBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface UpdateRuleInternalServerError
 */
export interface UpdateRuleInternalServerError {
    /**
     * 
     * @type {UpdateRuleInternalServerErrorBody}
     * @memberof UpdateRuleInternalServerError
     */
    Payload?: UpdateRuleInternalServerErrorBody;
}
/**
 * UpdateRuleInternalServerErrorBody UpdateRuleInternalServerErrorBody UpdateRuleInternalServerErrorBody UpdateRuleInternalServerErrorBody UpdateRuleInternalServerErrorBody UpdateRuleInternalServerErrorBody UpdateRuleInternalServerErrorBody update rule internal server error body
 * @export
 * @interface UpdateRuleInternalServerErrorBody
 */
export interface UpdateRuleInternalServerErrorBody {
    /**
     * code
     * @type {number}
     * @memberof UpdateRuleInternalServerErrorBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof UpdateRuleInternalServerErrorBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof UpdateRuleInternalServerErrorBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof UpdateRuleInternalServerErrorBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof UpdateRuleInternalServerErrorBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof UpdateRuleInternalServerErrorBody
     */
    status?: string;
}
/**
 * The standard error format
 * @export
 * @interface UpdateRuleNotFound
 */
export interface UpdateRuleNotFound {
    /**
     * 
     * @type {UpdateRuleNotFoundBody}
     * @memberof UpdateRuleNotFound
     */
    Payload?: UpdateRuleNotFoundBody;
}
/**
 * UpdateRuleNotFoundBody UpdateRuleNotFoundBody UpdateRuleNotFoundBody UpdateRuleNotFoundBody UpdateRuleNotFoundBody UpdateRuleNotFoundBody UpdateRuleNotFoundBody update rule not found body
 * @export
 * @interface UpdateRuleNotFoundBody
 */
export interface UpdateRuleNotFoundBody {
    /**
     * code
     * @type {number}
     * @memberof UpdateRuleNotFoundBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof UpdateRuleNotFoundBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof UpdateRuleNotFoundBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof UpdateRuleNotFoundBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof UpdateRuleNotFoundBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof UpdateRuleNotFoundBody
     */
    status?: string;
}
/**
 * A rule
 * @export
 * @interface UpdateRuleOK
 */
export interface UpdateRuleOK {
    /**
     * 
     * @type {SwaggerRule}
     * @memberof UpdateRuleOK
     */
    Payload?: SwaggerRule;
}
/**
 * The standard error format
 * @export
 * @interface UpdateRuleUnauthorized
 */
export interface UpdateRuleUnauthorized {
    /**
     * 
     * @type {UpdateRuleUnauthorizedBody}
     * @memberof UpdateRuleUnauthorized
     */
    Payload?: UpdateRuleUnauthorizedBody;
}
/**
 * UpdateRuleUnauthorizedBody UpdateRuleUnauthorizedBody UpdateRuleUnauthorizedBody UpdateRuleUnauthorizedBody UpdateRuleUnauthorizedBody UpdateRuleUnauthorizedBody UpdateRuleUnauthorizedBody update rule unauthorized body
 * @export
 * @interface UpdateRuleUnauthorizedBody
 */
export interface UpdateRuleUnauthorizedBody {
    /**
     * code
     * @type {number}
     * @memberof UpdateRuleUnauthorizedBody
     */
    code?: number;
    /**
     * details
     * @type {Array<object>}
     * @memberof UpdateRuleUnauthorizedBody
     */
    details?: Array<object>;
    /**
     * message
     * @type {string}
     * @memberof UpdateRuleUnauthorizedBody
     */
    message?: string;
    /**
     * reason
     * @type {string}
     * @memberof UpdateRuleUnauthorizedBody
     */
    reason?: string;
    /**
     * request
     * @type {string}
     * @memberof UpdateRuleUnauthorizedBody
     */
    request?: string;
    /**
     * status
     * @type {string}
     * @memberof UpdateRuleUnauthorizedBody
     */
    status?: string;
}
/**
 * Upstream Upstream Upstream Upstream Upstream Upstream Upstream upstream
 * @export
 * @interface Upstream
 */
export interface Upstream {
    /**
     * PreserveHost, if false (the default), tells ORY Oathkeeper to set the upstream request\'s Host header to the hostname of the API\'s upstream\'s URL. Setting this flag to true instructs ORY Oathkeeper not to do so.
     * @type {boolean}
     * @memberof Upstream
     */
    preserve_host?: boolean;
    /**
     * StripPath if set, replaces the provided path prefix when forwarding the requested URL to the upstream URL.
     * @type {string}
     * @memberof Upstream
     */
    strip_path?: string;
    /**
     * URL is the URL the request will be proxied to.
     * @type {string}
     * @memberof Upstream
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface Version
 */
export interface Version {
    /**
     * Version is the service\'s version.
     * @type {string}
     * @memberof Version
     */
    version?: string;
}

/**
 * ApiApi - axios parameter creator
 * @export
 */
export const ApiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * > This endpoint works with all HTTP Methods (GET, POST, PUT, ...) and matches every path prefixed with /decision.  This endpoint mirrors the proxy capability of ORY Oathkeeper\'s proxy functionality but instead of forwarding the request to the upstream server, returns 200 (request should be allowed), 401 (unauthorized), or 403 (forbidden) status codes. This endpoint can be used to integrate with other API Proxies like Ambassador, Kong, Envoy, and many more.
         * @summary Access Control Decision API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decisions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/decisions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this method to retrieve a rule from the storage. If it does not exist you will receive a 404 error.
         * @summary Retrieve a rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRule', 'id', id)
            const localVarPath = `/rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Get service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns cryptographic keys that are required to, for example, verify signatures of ID Tokens.
         * @summary Lists cryptographic keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWellKnownJSONWebKeys: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/.well-known/jwks.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check alive status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isInstanceAlive: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/alive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check readiness status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isInstanceReady: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/health/ready`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This method returns an array of all rules that are stored in the backend. This is useful if you want to get a full view of what rules you have currently in place.
         * @summary List all rules
         * @param {number} [limit] The maximum amount of rules returned.
         * @param {number} [offset] The offset from where to start looking.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRules: async (limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiApiAxiosParamCreator(configuration)
    return {
        /**
         * > This endpoint works with all HTTP Methods (GET, POST, PUT, ...) and matches every path prefixed with /decision.  This endpoint mirrors the proxy capability of ORY Oathkeeper\'s proxy functionality but instead of forwarding the request to the upstream server, returns 200 (request should be allowed), 401 (unauthorized), or 403 (forbidden) status codes. This endpoint can be used to integrate with other API Proxies like Ambassador, Kong, Envoy, and many more.
         * @summary Access Control Decision API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async decisions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.decisions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this method to retrieve a rule from the storage. If it does not exist you will receive a 404 error.
         * @summary Retrieve a rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRule(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Get service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Version>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns cryptographic keys that are required to, for example, verify signatures of ID Tokens.
         * @summary Lists cryptographic keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWellKnownJSONWebKeys(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonWebKeySet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWellKnownJSONWebKeys(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check alive status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isInstanceAlive(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isInstanceAlive(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check readiness status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isInstanceReady(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isInstanceReady(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This method returns an array of all rules that are stored in the backend. This is useful if you want to get a full view of what rules you have currently in place.
         * @summary List all rules
         * @param {number} [limit] The maximum amount of rules returned.
         * @param {number} [offset] The offset from where to start looking.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRules(limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Rule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRules(limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiApiFp(configuration)
    return {
        /**
         * > This endpoint works with all HTTP Methods (GET, POST, PUT, ...) and matches every path prefixed with /decision.  This endpoint mirrors the proxy capability of ORY Oathkeeper\'s proxy functionality but instead of forwarding the request to the upstream server, returns 200 (request should be allowed), 401 (unauthorized), or 403 (forbidden) status codes. This endpoint can be used to integrate with other API Proxies like Ambassador, Kong, Envoy, and many more.
         * @summary Access Control Decision API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        decisions(options?: any): AxiosPromise<void> {
            return localVarFp.decisions(options).then((request) => request(axios, basePath));
        },
        /**
         * Use this method to retrieve a rule from the storage. If it does not exist you will receive a 404 error.
         * @summary Retrieve a rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule(id: string, options?: any): AxiosPromise<Rule> {
            return localVarFp.getRule(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Get service version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: any): AxiosPromise<Version> {
            return localVarFp.getVersion(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns cryptographic keys that are required to, for example, verify signatures of ID Tokens.
         * @summary Lists cryptographic keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWellKnownJSONWebKeys(options?: any): AxiosPromise<JsonWebKeySet> {
            return localVarFp.getWellKnownJSONWebKeys(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check alive status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isInstanceAlive(options?: any): AxiosPromise<HealthStatus> {
            return localVarFp.isInstanceAlive(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
         * @summary Check readiness status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isInstanceReady(options?: any): AxiosPromise<HealthStatus> {
            return localVarFp.isInstanceReady(options).then((request) => request(axios, basePath));
        },
        /**
         * This method returns an array of all rules that are stored in the backend. This is useful if you want to get a full view of what rules you have currently in place.
         * @summary List all rules
         * @param {number} [limit] The maximum amount of rules returned.
         * @param {number} [offset] The offset from where to start looking.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRules(limit?: number, offset?: number, options?: any): AxiosPromise<Array<Rule>> {
            return localVarFp.listRules(limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI {
    /**
     * > This endpoint works with all HTTP Methods (GET, POST, PUT, ...) and matches every path prefixed with /decision.  This endpoint mirrors the proxy capability of ORY Oathkeeper\'s proxy functionality but instead of forwarding the request to the upstream server, returns 200 (request should be allowed), 401 (unauthorized), or 403 (forbidden) status codes. This endpoint can be used to integrate with other API Proxies like Ambassador, Kong, Envoy, and many more.
     * @summary Access Control Decision API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public decisions(options?: any) {
        return ApiApiFp(this.configuration).decisions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this method to retrieve a rule from the storage. If it does not exist you will receive a 404 error.
     * @summary Retrieve a rule
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public getRule(id: string, options?: any) {
        return ApiApiFp(this.configuration).getRule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the service version typically notated using semantic versioning.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
     * @summary Get service version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public getVersion(options?: any) {
        return ApiApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns cryptographic keys that are required to, for example, verify signatures of ID Tokens.
     * @summary Lists cryptographic keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public getWellKnownJSONWebKeys(options?: any) {
        return ApiApiFp(this.configuration).getWellKnownJSONWebKeys(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a 200 status code when the HTTP server is up running. This status does currently not include checks whether the database connection is working.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
     * @summary Check alive status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public isInstanceAlive(options?: any) {
        return ApiApiFp(this.configuration).isInstanceAlive(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns a 200 status code when the HTTP server is up running and the environment dependencies (e.g. the database) are responsive as well.  If the service supports TLS Edge Termination, this endpoint does not require the `X-Forwarded-Proto` header to be set.  Be aware that if you are running multiple nodes of this service, the health status will never refer to the cluster state, only to a single instance.
     * @summary Check readiness status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public isInstanceReady(options?: any) {
        return ApiApiFp(this.configuration).isInstanceReady(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This method returns an array of all rules that are stored in the backend. This is useful if you want to get a full view of what rules you have currently in place.
     * @summary List all rules
     * @param {number} [limit] The maximum amount of rules returned.
     * @param {number} [offset] The offset from where to start looking.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listRules(limit?: number, offset?: number, options?: any) {
        return ApiApiFp(this.configuration).listRules(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}


